---
title: "health data Melbourne"
author: "Chris Jackson, Belen Zapata-Diomedi, Steve Pemberton"
email: "chris.jackson@mrc-bsu.cam.ac.uk, mbzd2@cam.ac.uk, , steve.pemberton@rmit.edu.au"
date: today
format: 
  html:
    code-fold: true
    embed-resources: true
    df-print: paged
execute: 
    message: false
    warning: false
toc: true
number-sections: true
editor_options:
  mode: visual
  markdown:
    wrap: 72
---

# Introduction

This document explains and produces estimates for the inputs for the
health model for JIBE Melbourne The model initially has four stages
where individuals are in a healthy state, might become diseased of one
or more diseases, and die from any causes (all cause mortality). All
cause mortality is also dependent on diseases status, meaning that if a
person has a given disease (i.e. diabetes, dementia, parkinson, cancers,
copd) their probability of dying is higher. Diabetes is a risk factor
for cardiovascular diseases (ischemic heart disease and stroke) and
included in the model. The model does not include trend of diseases but
assumes that current rates by age, sex and area will be observed in the
future.

The purpose of this document is to produce health inputs for all-cause
mortality and diseases' incidence and prevalence. Prevalence is used to
assign initial state as diseased.

```{r setup, include=FALSE}

rm(list = ls())

library(tidyverse)
library(readxl)
library(openxlsx)
library(readr)
library(knitr)
library(jsonlite)
library(kableExtra)
library(gt)
library(rjson)
library(ggforce)
library(here) # to get files from the current working directory

# set root directory one level up from currentdirectory
knitr::opts_knit$set(root.dir = dirname(getwd()))

# functions
source("docs/functions/interpolation.R")

# Avoid scientific notation
options("scipen"=100, "digits"=4)



knitr::opts_chunk$set(
  echo = FALSE,          # Hide code by default
  # results = "hide",      # Hide results by default
  message = FALSE,       # Suppress messages
  warning = FALSE)        # Suppress warnings
```

## Data needs

We need annual probability data for all cause mortality and diseases
incidence and prevalence. We also will need data for trends in mortality
and diseases incidence. For prevalence we need rates for baseline (2018)
and later years for validation. For disease incidence and prevalence,
data is required for the list of diseases below in Table 1, which
correspond to the included risk factors in the model (PM2.5, NO2, noise,
ndvi, physical activity). Disease names correspond to the names from
data source. For example, we use data from the GBD for Alzheimer's
disease and other dementias, the corresponding systematic review and
meta analysis (SRMA) uses a different name (All cause dementia). Given
differences in names and categories of diseases used, we provide ICD-10
codes and aim to match up as much as possible.

Also see excel file (disease_data, Melbourne final).

```{r}
health_outcomes_risks <- tibble::tribble(
  ~"Disease",  ~"Data source age and sex incidence (ICD code)", ~"Data source inequalities incidence",   ~"Physical activity DRF (ICD-10)", ~"PM2.5 (ICD-10 code)", ~"NO2 (ICD-10 code)", ~"Noise (ICD code)", 
  "Stroke", "GBD (G45-G46.8, I60-I62, I62.9-I64, I64.1, I65-I69.998, Z82.3)", "AIHW (I60-I66)", "PA (I60-I66)", "#", "#", "#",
  "Coronary heart disease", "GBD (I20-I21.6, I21.9-I25.9, Z82.4-Z82.49)", "AIHW (I20-I25) [to confirm: CVD is I00-I99]",  "PA (I20-I25)", "#", "#", "#",
  "Breast cancer",  "AIHW (C50)", "ATLAS (C50)","PA (C50)", "#", "#", "#",
  "Endometrial cancer",  "AIHW (C54.1)", "ATLAS (C54-C55)","PA (C54)", "#", "#", "#",
  "Lung cancer",  "AIHW (C33-C34)", "ATLAS (C33-C34)","PA (C34)", "#", "#", "#",
  "Colon cancer",  "AIHW (18)", "ATLAS (C18-C20)","PA (C18)", "#", "#", "#",
  "Esophageal cancer",  "AIHW (C15)", "ATLAS (C15)","PA (C15)", "#", "#", "#",
  "Liver cancer",  "AIHW (C22)", "ATLAS (C22)","PA (C22-C24)", "#", "#", "#",
  "Kidney cancer",  "AIHW (C64)", "ATLAS (C64)","PA (C64-65)", "#", "#", "#",
  "Gastric cardia cancer",  "AIHW (C16)", "ATLAS (C16)","PA (C16.0)", "#", "#", "#",
  "Myeloid leukemia",  "AIHW (C92.1)", "ATLAS (C91-C95)","PA (C92)", "#", "#", "#",
  "Myeloma",  "AIHW (C90.0)", "ATLAS (C90)","PA (90)", "#", "#", "#",
  "Head and neck cancer",  "AIHW (C00-C14, C30-C32)", "ATLAS (C00-C14, C30-C32)","PA (C76.0)", "#", "#", "#",
  "Rectum cancer",  "AIHW (C19-C20)", "ATLAS (C18-C20)","PA (C20)", "#", "#", "#",
  "Bladder cancer",  "AIHW (C67)", "#","PA (C67)", "#", "#", "#",
  "Prostate cancer",  "AIHW (C61)", "ATLAS (C61)","PA (C61)", "#", "#", "#",
  "Malignant melanoma",  "AIHW (C43)", "ATLAS (C43)","PA (C43)", "#", "#", "#",
  "Depressive disorders", "GBD (F32-F33.9, F34.1)", "#", "PA (F32-F33)", "#", "#", "#",
  "All cause dementia",  "GBD (F00-F02.0, F02.8-F03.91, F06.2, G30-G31.1, G31.8-G32.89)", "#","PA (F01-F03)", "#", "#", "#",
  "Diabetes type 2", "GBD (E11-E11.1, E11.3-E11.9)", "AIHW (E11)", "PA", "#", "#", "#",
  "Chronic obstructive pulmonary disease",  "GBD (J41-J42.4, J43-J44.9)", "AIHW (J40-J44)","PA", "#", "#", "#"
)

inputs <- kableExtra::kable(
  health_outcomes_risks, 
  booktabs = TRUE, 
  caption = "Diseases", 
  longtable = TRUE
)

inputs

```

Notes on diseases, diseases sources of data and risk factors ICD-codes.

[**Depression**]{.underline}

Systematic review and meta-analysis for depression
([10.1001/jamapsychiatry.2022.0609](https://doi.org/10.1001%2Fjamapsychiatry.2022.0609))
defines depression as (1) presence of major depressive disorder
indicated by self-report of physician diagnosis, registry data, or
diagnostic interviews using DSM criteria of International Statistical
Classification of Diseases and Related Health Problems, tenth edition,
codes F32 through F33; (2) elevated depressive symptoms established
using validated cut-offs for a depressive screening instrument.

Data for depressive disorders is from the GBD study includes codes
F32-F33.9 (Major depressive disorders) and F34.1 (Disthymia). We then
include data for depressive disorders for incidence and prevalence by
age and sex (from GBD). We did not find publicly available data for
representing inequalities in health for depression.

Evidence suggest that females and younger peoples have higher rates of
depression than males, which we capture already with age and sex
incidence and prevalence estimates. Household income was also a
significant predictor of depression among females. The data for this
study is old, 2007, and cross sectional survey (10.3390/app122412685)

[**All-cause dementia**]{.underline}

The ICD-10 code was obtained from personal communications with Leandro
Garcia, while DRFs are available in the DRF online interface
([Meta-Analyses Physical Activity
(cam.ac.uk)](https://shiny.mrc-epid.cam.ac.uk/meta-analyses-physical-activity/)),
it is not reported in a peer-reviewed publication.

[**Diabetes type 2**]{.underline}

Could not find ICD-10 code in SRMA
(<https://doi.org/10.1007/s00125-016-4079-0>).

## Inequalities in health

In Jibe we aim to represent inequalities in health, thus, we include
inequalities in our estimates of health to the extend of this being
possible using publicly available data. We need data by age and sex at
the minimum, and additional data representing inequalities will be used
as much as possible. The initial datais then by age and sex with
additional data sources used to further disaggregate, for example, by
area, level of socioeconomic deprivation and education. Data to
dissagregate is available in different formats, for example, a relative
risk to indicate the increased/decrease risk for a given group in
comparison to a reference group or rates comparing different population
groups. If relative risks are supplied, we apply those to modify the
data, if not, we need to derive a RR, for the second, we use the below
methods developed by Chris Jackson for mortality data for Melbourne and
we applied them more broadly across diseases, when suitable.

We use the following method to disagregate an event rate (for example,
incidence or mortality by age and sex) by a further risk factor (such as
socio-economic status). Given

-   the rate $r_{ave}$ by age and sex, averaged over people with or
    without the risk factor

-   a relative (unstandardised) rate $RR$ between people with/without
    the risk factor

-   the proportions of people with the risk factor $p_1$ and without the
    risk factor $p_0$

we can estimate the rates with ($r_1$) and without the risk factor
($r_0$), because if
$r_{ave} = p_1 r_1 + p_0 r_0 = p_1 r_0 RR + p_0 r_0$, we can estimate
$r_0 = r_{ave} / (p_1 RR + p_0)$.

This generalises to categorical risk factors with more than two
categories $i=1,2,3...$, such as a area socioeconomic indicator. Suppose
$r_1$ is the mortality rate in some reference group $i$, $p_i$ is the
proportion of people in group $i$, and $RR_i$ is the relative risk
associated with being in this group compared to group $i=1$, so that
$RR_1=1$. Given

$r_{ave} = r_1 \sum_{i=1}^G p_i RR_i$

we can compute $r_1$ given $r_{ave}$, the relative rates for the risk
factor $RR_i$ and population proportions for the risk factor $p_i$.
Hence we can compute the remaining $r_i$ by multiplying $r_1$ by $RR_i$.

**Implementation of disaggregation of risks**

Where we disaggregate data across quintiles of socioeconomic status, we
assume that $p_i = 1/5$ is the proportion of people in each of the five
quintiles, and these proportions are the same for each age/sex group.
The quintiles are defined so that the same number of areas falls in each
quintile. So while this assumption will not be exact, it is expected to
be approximately true. To get better estimates of these proportions, we
would need data on the population by age, sex and SES quintile.

The code to perform this disaggregation works by stretching out the
age/sex data vertically to create a dataset with one row per combination
of age, sex and socioeconomic quintile. This is then joined with the
dataset on relative incidence by socioeconomic quintiles. The term
$\sum_{i=1}^G p_i RR_i$ is then computed as sum_pRR, and joined to the
streched incidence dataset. This allows the disaggregated rates rate to
be computed in a vectorised way.

# Incidence data

## Incidence data by age and sex

We use GBD data as the age and sex data for incidence estimates except
for cancers. For cancers we use Australian Institute of Health and
Welfare (AIHW) data.

### Global Burden of disease data for Australia: data interpolation

Prepare incidence data, and prevalence data which will be used in
'Prevalence data' below, by sex and single year of age. To do so, we
interpolate the data between age groups. Four interpolation functions
are available in folder functions and script interpolation.R were
developed to test which one fits the data best. Graphs are created and
saved in docs/images/inc_gbd_age_sex to visually check the fit of the
interpolation to the original data.

```{r}

# GBD data for Melbourne. 
gbd <- bind_rows(
  read.csv(here("melbourne/health/original/GBD/gbd_incidence_2018_2019.csv")),
  read.csv(here("melbourne/health/original/GBD/gbd_incidence_2020_2021.csv")),
  read.csv(here("melbourne/health/original/GBD/gbd_prevalence_2018_2019.csv")),
  read.csv(here("melbourne/health/original/GBD/gbd_prevalence_2020_2021.csv")))

# Filter data to needed variables and remove strings from GBD age variable and create from_age and to_age needed for interpolation. 

gbdp <- gbd %>%
  filter(metric %in% "Rate") %>%
  select(-c(location, upper, lower)) %>%
  filter(!age %in% "All ages") %>%
  filter(!cause %in% "All causes") %>%
  mutate(rate_1=val/100000) %>% 
  # some ages have 'years' (eg 5-9 years), while others don't (eg 80-84); omit 'years'
  mutate(age = gsub(" years", "", age)) %>%
  tidyr::extract(age, c("from_age", "to_age"), "(.+)-(.+)", remove=FALSE, convert=TRUE) %>%
  mutate(from_age = case_when(age=="95+"  ~  95L,
                              age=="<5"  ~  0L,
                              TRUE  ~  from_age),
         to_age = case_when(age=="95+"  ~  99L,
                            age=="<5"  ~  4L,
                            TRUE  ~  to_age),
         agediff = to_age - from_age + 1,
          val1yr = rate_1) %>% 
  #we do not distribute amongst age groups as it is a rate but assume same within age group
 rename(agegroup = age) 


# Now stretch the data out using an index, to create a data frame with 1 row per year of age and create a variable for year of age. The age group rate repeats within single years of age in the group. 
index <- rep(1:nrow(gbdp), gbdp$agediff)
gbdpyrd5 <- gbdp[index,] %>%
  mutate(ageyr = from_age + sequence(gbdp$agediff) - 1)
gbdpyrd5 <- gbdpyrd5 %>% 
  select(measure, ageyr, sex, agegroup, from_age, to_age, cause, year, val1yr,rate_1) 


# Apply the disaggregation function

# Group data for dissaggregation

gbdp_grp <- gbdp %>%
  group_by(measure, year, sex, cause) %>%
  arrange(measure, year, sex, cause, from_age)

# Apply function (select a function from 'functions/interpolation.R'). Smooth_spline does a good job.
gbdpyr_interp <- group_modify(gbdp_grp, disagg_smooth_spline) %>%
  ungroup()

#Join with original data where rates are the same within groups to validate interpolated data
gbdpyr_interp <- gbdpyr_interp %>%
  left_join(gbdpyrd5, by = c("measure", "year", "ageyr", "sex", "cause"))

# Extract the 2018 incidence values
gbdpyr <- gbdpyr_interp %>%
  filter(measure == "Incidence" & year == 2018)

# Plot data to check interpolated values against 5-year age group values (original data)
## Four interpolation function could be use, the best fit should be used. For now, best fit to the data assessed visually.

# Melt the data to long format for ggplot
plot_data <- gbdpyr %>%
  select(measure, cause, sex, ageyr, rate_1, val_interpolated) %>%
  pivot_longer(cols = c(rate_1, val_interpolated), names_to = "type", values_to = "value")

# Generate and save all pages
output_dir <- here("images/Melbourne/inc_gbd_age_sex/")
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

plot_interpolation_pages(plot_data, output_dir)
```

### Australian Institute of Health and Welfare data for Australia: data interpolation

#### Harmonise definitions of cancer sites

The cancer sites are reported differently between the AIHW tables on
incidence by age/sex and incidence by socioeconomic quintiles and also
from the cancer ATLAS. While the final data uses ATLAS, as opposed to
AIHW, initial code from Chris used AIHW and we also include the AIHW
socioeconomic data below for comparison purposes, so we still harmonise,
also to match standard names used across different inputs (i.e. health
data, dose response functions).

This table details the assumptions that are made in order to match the
corresponding rates between the AIHW tables, we manually change the
names for the ATLAS data. The sites that we intend to use are defined by
stdname and ICD-10 and these names correspond to the names use in the
physical activity SRMA by Garcia et al, and associated package. Each row
of the table below details the site from the AIHW tables that these are
assumed to be matched to.

Note, sites are the same as causes in GBD.

```{r}

sites <- rbind( 
    ## Standard name,   Name in AIHW age/sex data,  Name in AIHW socio data,   Our intended ICD10,
    c("Breast cancer",   "Breast cancer"  ,      "Breast cancer in females (C50)" , "C50"),
     c("Endometrial cancer", "Endometrial cancer", "Uterine cancer (C54–C55)" ,  "C54–C55"),
      c("Lung cancer",       "Lung cancer",         "Lung cancer (C33–C34)",  "C33–C34"),
      c("Colon cancer",     "Colon cancer",         "Colorectal cancer (C18–C20)", "C18"),
      c("Esophageal cancer", "Oesophageal cancer" , NA,  "C15"),  
      c("Liver cancer",      "Liver cancer",       "Liver cancer (C22)", "C22"),
      c("Kidney cancer",     "Kidney cancer",    "Kidney cancer (C64)", "C64"),
      c("Gastric cardia cancer",  "Stomach cancer", NA, "C16"),
      c("Myeloid leukemia", "Chronic myeloid leukaemia (CML)"  , NA, "C92.1"),
      c("Myeloma", "Multiple myeloma", NA, "C90.0"),
      c("Head and neck cancer", "Head and neck cancer (including lip)", "Head and neck cancers (with lip) (C00–C14, C30–C32)", "C01–C14, C30–C32"),
      c("Rectum cancer", "Rectal cancer (including rectosigmoid junction)", "Colorectal cancer (C18–C20)", "C20"),
      c("Bladder cancer", "Bladder cancer", "Bladder cancer (C67)", "C67"),
      c("Prostate cancer", "Prostate cancer", "Prostate cancer (C61)", "C61"),
      c("Malignant melanoma", "Melanoma of the skin", "Melanoma of the skin (C43)", "C43"),
    c("All cancers", "All cancers combined", "All cancers combined (C00–C97, D45, D46, D47.1, D47.3–D47.5)", "C00–C97, D45, D46, D47.1, D47.3–D47.5")
    ) |> 
    as_tibble() |>
    setNames(c("stdname","agesexname","socioname","ICD10") ) |>
    select(stdname, ICD10, agesexname, socioname)

## This table is causing error, to be fixed (2/08/2024)
knitr::kable(sites, col.names = c("Standardised name","ICD 10 code",
             "Closest site in age/sex data","Closest site in socioeconomic data"))

# assume unique row in age-sex data for each standard site
stopifnot(!any(duplicated(sites$agesexname))) 
```

### Interpolate incidence by age and sex

```{r, echo=FALSE}

inc <- read_xlsx(here("melbourne/health/original/AIHW/cancer-incidence.xlsx"), sheet="Table S1a.1", skip=5, col_names=TRUE) %>% 
    select(sex = Sex, age = "Age group (years)",
           site = "Cancer group/site",
           rate = "Age-specific rate\r\n(per 100,000)",
           year = Year) %>%
    filter(age != "All ages combined",
           sex != "Persons") %>%
    mutate(age = ifelse(age=="90+","90–94",age), 
           rate_1=rate/100000) %>%
    separate_wider_delim(age, "–", names = c("from_age","to_age")) %>%
      mutate(across(from_age:to_age, as.numeric),
             agediff = to_age - from_age + 1) 

# to match other data add an age group from 95 to 99

inc_95 <- inc %>%
  filter(from_age == 90) %>%
  mutate(from_age = case_when(
    from_age == 90 ~ 95,  # Change `from_age` from 90 to 95
    TRUE ~ from_age       # Keep other values unchanged
  ),
  to_age = case_when(
    to_age == 94 ~ 99,    # Change `to_age` from 95 to 99
    TRUE ~ to_age         # Keep other values unchanged
  ))

inc <- inc %>% bind_rows(inc_95) %>%
  mutate(site = sites$stdname[match(site, sites$agesexname)]) %>%
  # Filter rows with valid site names
  filter(site %in% sites$stdname)

# Data expanded to one year age groups with 5-year value by sex and site repeated for each one year age group within age group. 

# Create index for repeating rows

index <- rep(1:nrow(inc), inc$agediff)

# Create the modified dataframe with repeated rows
incyrd5 <- inc[index, ]

# Additional processing if required, e.g., adding the ageyr column
# Assuming from_age, agediff, and other required columns are correctly defined
incyrd5 <- inc %>%
 mutate(across(from_age:to_age, as.numeric),
             agediff = to_age - from_age + 1) |>
    group_by(year, sex, site) |>
    slice(rep(1:n(), agediff)) %>%
    mutate(ageyr = row_number() - 1)

# Ensure that age is within the specified range (if necessary, based on incyrd5)
stopifnot(inc$ageyr >= inc$from_age, inc$ageyr <= inc$to_age)


# Group data for dissaggregation

inc_grp <- inc %>%
  group_by(year, site, sex) %>%
  arrange(year, site, sex, from_age)

# Apply function (select a function from 'functions/interpolation.R'). Smooth_spline does a good job.
incyr_interp <- group_modify(inc_grp, disagg_smooth_spline) %>%
  ungroup()

# Add age group 95 to 99, interpolation does not apply as same values for starting and end range

# Step 1: Filter rows where ageyr == 95
incyr_95 <- incyr_interp %>%
  filter(ageyr == 95)

# Step 2: Repeat the filtered rows and change ageyr to 96, 97, 98, and 99
incyr_repeated <- incyr_95 %>%
  slice(rep(1:n(), each = 4)) %>%
  mutate(ageyr = case_when(
    row_number() %% 4 == 1 ~ 96,
    row_number() %% 4 == 2 ~ 97,
    row_number() %% 4 == 3 ~ 98,
    row_number() %% 4 == 0 ~ 99
  ))

# Join with original data where rates are the same within groups to validate interpolated data
incyr_interp <-incyr_interp %>% 
  bind_rows(incyr_repeated) %>%
  left_join(incyrd5, by = c("year", "ageyr", "sex", "site")) %>%
  mutate(site=tolower(site))

# Extract the 2016 rates (we use 2016 to match inequality data)
incyr <- incyr_interp %>%
  filter(year == 2016)

# Plot data to check interpolated values against 5-year age group values (original data)

# Melt the data to long format for ggplot
plot_data <- incyr %>%
  rename(cause = site) %>%
  pivot_longer(cols = c(rate_1, val_interpolated), names_to = "type", values_to = "value")

# Generate and save all pages
output_dir <- here("images/Melbourne/inc_aihw_age_sex/")
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

plot_interpolation_pages(plot_data, output_dir)
```

## Inequalities

Above data is by age and sex, but we are interested in further
disaggregation to represent inequalities in health. Preparation of
inequalities data responds to inequality data availability for the
following groups of diseases or single diseases: cancer, cardiovascular
diseases and diabetes, COPD. For depression we did not find any data
representing inequalities. Data sources are outlined here:
[health](https://rmiteduau.sharepoint.com/:f:/r/sites/JIBEworkinggroup/Shared%20Documents/General/health?csf=1&web=1&e=BaifAr)

### Cancers

#### Socioeconomic data from Cancer Atlas

We have data from the Cancer Atlas, by SA2 area and for males, females
and persons. This is modeled data and methods are explained here
(https://atlas.cancer.org.au/developing-a-cancer-atlas/) and here
(https://pubmed.ncbi.nlm.nih.gov/31570101/). Data is available for the
below cancer types and by SA2 area defined by the Australian Statistical
Geography Standard July 2011 edition, with data on Capital Cities for
Australia so we can select Melbourne. We joined all diseases data for
incidence, for males and females, by SA2 area. Data is for standardised
incidence ratio (SIR). The SIR reflects the area-specific incidence rate
relative to the Australian average. It is the ratio of the observed
cancer cases to the expected number of cases, the latter adjusting for
difference in population between SA2 and differences in age structure of
the population with an SA2. Data for the Australian average by age and
sex is from AIHW and interpolated data was generated above named incyr.

```{r}
# Get sheet with SA2 areas by SES and filter Victoria [SP: currently the filter for Victoria is commented out; is that intentional?] BZD: yes, to be able to check the with national level data


excel_file <- loadWorkbook(here("melbourne/health/original/ATLAS 2/ACA 2 - Diagnosis relative estimates.xlsx"))

# Get the sheet names
sheet_names <- names(excel_file)

# Define the string that should be in the sheet names
search_string <- "invasi" #we just keep invasive cancer, stages are within invasive. in situ, localised, is not available as added to invasive. Most data for invasive and for previous ATLAS data we ony had invasive cancer. However, in some sheets (eg head and neck cancers, 'invasive' is abbreviated)

# Filter sheets to keep: those containing the string or the first 5 sheets
sheets_to_keep <- sheet_names[1:5]  # Keep first 5 sheets
sheets_with_string <- sheet_names[grepl(search_string, sheet_names)]  # Sheets with the string

# Combine the two criteria
sheets_to_keep <- unique(c(sheets_to_keep, sheets_with_string))

# Remove the sheets that are not in sheets_to_keep
sheets_to_remove <- setdiff(sheet_names, sheets_to_keep)

# Remove the sheets
for(sheet in sheets_to_remove) {
  removeWorksheet(excel_file, sheet)
}

## Now remove the invasive string from the sheet names
# Get the current sheet names
sheet_names <- names(excel_file)

# Define the string to remove
string_to_remove <- " - invasi.*"

# Modify sheet names by removing the specified string
new_sheet_names <- gsub(string_to_remove, "", sheet_names)

# Rename sheets only if the sheet name changed
for (i in seq_along(sheet_names)) {
  if (sheet_names[i] != new_sheet_names[i]) {
    renameWorksheet(excel_file, sheet = sheet_names[i], newName = new_sheet_names[i])
  }
}

# Save the workbook with the updated sheets
saveWorkbook(excel_file, here("melbourne/health/original/ATLAS 2/ATLAS_clean.xlsx"), overwrite = TRUE)


# Open file 
excel_file <- here("melbourne/health/original/ATLAS 2/ATLAS_clean.xlsx")

# Get the names of the sheets in the Excel workbook
diseases <- excel_sheets(excel_file)[-c(1:5)]

## Males
all_data_males <- list()

# Loop through each disease
for (sheet_name in diseases) {
  
   if (sheet_name %in% c("Breast cancer", "Uterine cancer", "Cervical cancer", "Ovarian cancer", "Testicular cancer", "Prostate cancer", "Vulvar cancer")) {
    next  # Skip to the next iteration of the loop includes cancer for females only and also testicular cancer, we do not model and messes up columns patterns
  }
  
  # sheet_name = "All cancers"
  
  # Read data for the current disease
  data <- read_xlsx(excel_file, 
    sheet = sheet_name, 
    col_names = TRUE, 
    n_max = 2400) %>%
    select(1:8, 13, 16) %>%
  mutate(sex="Males",
           site = sheet_name)
  
  # Store the processed data in the list
  all_data_males[[sheet_name]] <- data
}

# Done outside loop as diff columns format

prostate_cancer <- read_xlsx(excel_file,
    sheet = "Prostate cancer", 
    col_names = TRUE, 
    n_max = 2400) %>%
    mutate(sex = "Males",
           site = "Prostate cancer")  %>%
    select(1:9, 12:14)

# Bind all data frames together
final_data_males <- do.call(rbind, all_data_males) %>% 
                   bind_rows(prostate_cancer) %>% 
                  rename("Probability differs from Aust average"= "Probability differs from Aust average - Males",
                         "SIR"="Estimate - Males" )

## females
all_data_females <- list()

# Loop through each disease
for (sheet_name in diseases) {
  
  
  if (sheet_name %in% c("Testicular cancer", "Prostate cancer")) {
    next  # Skip to the next iteration of the loop includes cancer for females only and also testicular cancer, we do not model and messes up columns patterns
  }
  # Read data for the current disease
  data <- read_xlsx(excel_file, 
    sheet = sheet_name, 
    col_names = TRUE, 
    n_max = 2400
  )  %>%
    select(1:12) %>%
  mutate(sex="Females",
           site = sheet_name)
  
  # Store the processed data in the list
  all_data_females[[sheet_name]] <- data
}

# Bind all data frames together
final_data_females <- do.call(rbind, all_data_females) %>%
    select(1:9, 12:14) %>% 
                  rename("Probability differs from Aust average"= "Probability differs from Aust average - Females",
                         "SIR"="Estimate - Females" )

SA2_soc <- read_xlsx(excel_file, sheet="Geography", skip=11, col_names = TRUE, n_max=2200)


# Population from 2016 census

pop_SA2 <- read_csv(here("melbourne/health/original/ABS/Population by SA2 area.csv"), skip = 9, col_names = TRUE) %>%
  # Set the first row as column names
  { setNames(.[-1, ], unlist(.[1, ]))} %>%
   {names(.)[4] <- "population"; .}  %>%
   as.data.frame() %>%
  fill(SA2, .direction = "down") %>%
  fill(`SEXP Sex`, .direction = "down") %>%
  rename(sex = `SEXP Sex`, 
         age = `AGEP Age`, 
         sa2_name = SA2) %>% 
  mutate(age=as.numeric(age))



data_combined <- bind_rows(final_data_females, final_data_males) %>%
  mutate(`SA2 code`=as.numeric(`SA2 code`)) %>%
 left_join(SA2_soc) %>% rename(SA2 = `SA2 name`)
# %>% filter(State=="Victoria", Remoteness=="Major city", `Capital cities`=="Greater Melbourne")


# Create a variable to indicate whether the average by age and sex should be  multiplied by the SIR, depending on the probability of the SA2 value differing from  Australian average
# Probability differs from Australian average
# This value ranges from 0 (low) to 1 (high) and represents the probability that  # the area's estimate is different to the Australian average. 
# If the standardised incidence ratio (SIR) is above 1, and the probability is high # (>0.6), then it is likely this area really has a higher diagnosis rate than the # national average. 
# If the standardised incidence ratio (SIR) is below 1, and the probability is high (>0.6),# # then it is likely this area really has a lower diagnosis rate than the # national average. 

data_combined <- data_combined %>%  mutate(diff = ifelse(SIR > 1 & `Probability differs from Aust average` > 0.6, "yes", ifelse(SIR < 1 & `Probability differs from Aust average` > 0.6, "yes", "no")))  %>%
  mutate(`Socioeconomic index` = case_when(
    `Socioeconomic index` == "Middle" ~ "Middle SES",
    TRUE ~ `Socioeconomic index`  # Handle default case
  ))
```

**Combining data sources**

We combined incidence data by age and sex for Australia wide with data
for SA2 area. Data for SA2 area (data_combined) from the Atlas gives us
the SIR, which is interpreted as the relative rate of incidence for an
area, by sex to the Australian average. The Australian average is from
AIHW and already stretched to one year age groups in data incyr.

Select data for health model in JIBE. Rate by sex, age and area is
simply created by multiplying Standardized Incidence Rate (SIR) by age
and sex rate.

```{r, echo=FALSE}

#Select diseases from ATLAS combined data
data_combined <- data_combined %>% filter(!(site %in% c("Brain Cancer", "Cervical Cancer", "Myeloproliferative neoplasms", "Non-Hodgkin Lymphoma", "Ovarian Cancer", "Pancreatic Cancer", "Thyroid Cancer"))) %>% mutate(site=tolower(site)) 

# Atlas does not have data for bladder cancer, use data for all cancers and for colon and rectum separately, then use combined (bowel cancer) for each. 

## ATLAS 2 has bowel cancer
# bladder_cancer <- data_combined %>% filter(site=="all cancers") %>%
#   mutate(site = if_else(site == "all cancers", "bladder cancer", site))

rectum_cancer <- data_combined %>% filter(site=="bowel cancer") %>%
  mutate(site = if_else(site == "bowel cancer", "rectum cancer", site))
  
data_sa2_sex <- data_combined %>%
  mutate(site = if_else(site == "bowel cancer", "colon cancer", site)) %>%
           bind_rows(rectum_cancer) %>%
  mutate(site = if_else(site == "uterine cancer", "endometrial cancer", site),
         site = if_else(site == "oesophageal cancer", "esophageal cancer", site),
         site = if_else(site == "melanoma", "malignant melanoma", site),
         site = if_else(site == "stomach cancer", "gastric cardia cancer", site), 
         site = if_else(site == "leukaemia", "myeloid leukemia", site),
         site = ifelse(site == "head and neck cancers", "head and neck cancer", site)) 


## Combine with incidence data by age and sex

cancer_incidence_area <- data_sa2_sex %>% left_join(incyr, by=c("sex", "site")) %>%
         mutate(rate_area=ifelse(diff=="yes", as.numeric(SIR)*val_interpolated,     val_interpolated)) %>%
         rename(socio=`Socioeconomic index`, #`Socioeconomic status` for ATLAS data
         sa2_code=`SA2 code`, 
         sa2_name = SA2) %>%
         mutate(prob=1 - exp(-rate_area)) %>%
         select(sa2_code, sa2_name, socio, site, age = ageyr, sex, prob, rate_area, val_interpolated) %>%
         mutate(rate_ave_100000=val_interpolated*100000,
         rate_area_100000=rate_area*100000) %>%
  mutate(sex = case_when(
    sex == "Females" ~ "Female",
    sex == "Males" ~ "Male")) %>%
  left_join(pop_SA2)

# Calculate weighted average from SA2 data to data by socioeconomic status. 

compare_socio <- cancer_incidence_area %>%
  # Filter out rows where population is NA to avoid issues with the weighted mean
  filter(!is.na(population), !is.na(rate_area_100000)) %>%
  group_by(age, sex, site, socio, rate_ave_100000) %>%
  summarise(
    # Only calculate the weighted mean if both rate_area_100000 and population are available
    rate_area_100000_ave = if (all(is.na(rate_area_100000)) || all(is.na(population))) {
      NA_real_  # Return NA if the entire group is NA
    } else {
      round(weighted.mean(rate_area_100000, population, na.rm = TRUE), 7)
    }
  ) %>%
  mutate(socio = as.factor(socio)) %>%
  filter(socio != "Not classified") %>%
 # Filter out 'Not classified' socio values
 ungroup()

## Dataset with average by age and sex calculated from area level data for comparison with original age and sex data from AIHW. 

compare_age_sex <- cancer_incidence_area %>%
  # Filter out rows where population is NA to avoid issues with the weighted mean
  filter(!is.na(population), !is.na(rate_area_100000)) %>%
  
  group_by(age, sex, site, rate_ave_100000) %>%
  summarise(
    # Only calculate the weighted mean if both rate_area_100000 and population are available
    rate_area_100000_av_age_sex = if (all(is.na(rate_area_100000)) || all(is.na(population))) {
      NA_real_  # Return NA if the entire group is NA
    } else {
      round(weighted.mean(rate_area_100000, population, na.rm = TRUE), 7)
    }
  ) %>%
 ungroup()

```

#### Socioeconomic data from AIHW (Chris)

As a point of comparison, we also have socioeconomic data from AIHW,
from the file cancer_socioeconomic.xlsx (published Dec 2021): Table
S10.7. By site and area socioeconomic quintile. These data refer to the
whole of Australia.

-   As per Cancer 2021 report socioeconomic status corresponds to the
    2016 area SA2 of usual residence (Appendix G of [Cancer in Australia
    (2021)](https://www.aihw.gov.au/getmedia/0ea708eb-dd6e-4499-9080-1cc7b5990e64/aihw-can-144.pdf?v=20230605165731&inline=true)).

-   For the cancer sites with missing socioeconomic gradients
    (esophageal, gastric, myeloid leukemia, myeloma), we will assume
    that socioeconomic gradient is the same as that for all cancers
    combined. This may not be true however. The socioeconomic gradient
    for all cancers is not large - this is largely because the most
    common cancers (breast, lung) have opposite gradients that cancel
    out.

-   Socioeconomic gradients are published for all colorectal cancer
    combined. These are assumed to be the same for colon and rectal
    cancer.

```{r, echo=FALSE}

## Compare data per SA2 and sex and data from national administrative sources by age, sex and combined with level of deprivation 

cancerinc_socio <- read_xlsx(here("melbourne/health/original/AIHW/cancer_socioeconomic.xlsx"), 
                             sheet="Table S10.7", skip=6, col_names = TRUE, n_max=90) %>%
  rename(site = `Cancer site/type (ICD-10 codes)`) %>%
  fill(site) %>%
  select(site, socio = "Socioeconomic area",
         rate = "ASR (per 100,000)...5") %>%
  filter(socio != "Australia") |> 
  mutate(socio = case_when(socio=="1 Lowest" ~ "1", # 1: lowest, to 5: highest
                           socio=="5 Highest" ~ "5",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  group_by(site) %>%
  mutate(rr = rate / first(rate)) %>%
  ungroup() %>%
  mutate(site = sites$stdname[match(site, sites$socioname)])  %>%
  filter(site %in% sites$stdname) 

## Esophageal, gastric cardia, myeloid leukemia and myeloma assumed to match all cancers
sociona_sites <- c("Esophageal cancer","Gastric cardia cancer","Myeloid leukemia","Myeloma")
nadf <- cancerinc_socio |> 
    filter(site == "All cancers") |>
    slice(rep(1:n(), length(sociona_sites))) |>
    mutate(site = rep(sociona_sites, each=5))

## For rectum cancer, assume same socioeconomic distribution as all colorectal cancer
dup_sites <- sites$stdname[!is.na(sites$socioname) & duplicated(sites$socioname)]
## Assume this is only one with a coarser site definition in the socioeconomic data
stopifnot(dup_sites == "Rectum cancer") # handle specially

dupdf <- cancerinc_socio |> 
    filter(site == "Colon cancer") |>
    mutate(site = "Rectum cancer")

cancerinc_socio <- cancerinc_socio |> 
    rbind(nadf) |>
    rbind(dupdf)

# disaggregate, using technique as described in 'inequalities in health' above
cancerinc_agesex <- incyr %>%
  # select required values, noting that we want the interpolated rates
  mutate(rate_interp = val_interpolated * 100000) %>%
  dplyr::select(site, age = ageyr, sex, rate_interp)

cancerinc <- cancerinc_agesex %>%
  # stretch out and join socioeconomic values
  slice(rep(row_number(), each=5)) %>%
  mutate(socio = rep(1:5, length.out=n())) %>%
  left_join(cancerinc_socio %>% 
              select(site, socio, rr_socio = rr) %>%
              mutate(site = tolower(site)), 
            by=c("site","socio")) %>%
  mutate(p_socio = 1/5,    # assumption
         pRR = p_socio * rr_socio,
         socio = ordered(socio))

sum_p <- cancerinc %>% 
    group_by(site, age, sex) %>%
    summarise(sum_pRR = sum(pRR), .groups="drop")
    
cancerinc <- cancerinc |>
    left_join(sum_p, by=c("site","age","sex")) %>%
    mutate(rate_soc = rate_interp * rr_socio / sum_pRR, # Change to rr_soc to keep original value (BZ-D 13-03-2024)
           socio = ordered(socio, labels = c("1 (most deprived)",
                                             "2","3","4",
                                             "5 (least deprived)")),
           sex = factor(sex),
           sex = fct_recode(sex, Female="Females", Male="Males")) #%>%
   # select(site, age, sex, socio, rate) # keeping all variables to track 

cancerinc <- cancerinc %>%
  mutate(socio = case_when(
    socio == "1 (most deprived)" ~ "Most disadvantaged",
    socio == "2" ~ "Disadvantaged",
    socio == "3" ~ "Middle SES", 
    socio == "4" ~ "Advantaged",
    socio == "5 (least deprived)" ~ "Most advantaged",
    TRUE ~ socio  # Handle default case
  )) %>%
mutate(socio=as.factor(socio)) %>%
  ungroup() %>%
  mutate(site=tolower(site))

compare_socio <- compare_socio %>% left_join(cancerinc, by=c("site", "age", "sex", "socio")) %>%
  # mutate(rate_soc=round(rate, 2)) %>% select(!rate) %>% 
  left_join(compare_age_sex)

compare_socio <- na.omit(compare_socio)
```

**Illustration of incidence estimates using AIHW socioeconomic data**

The published incidence by age and sex (averaged over deprivation
levels) is shown by the dotted black lines. The estimated incidence
disaggregated by socioeconomic quintile is shown by the coloured lines,
with socioeconomic status indicated by the lightness of the lines.

This shows that the relative risk between socioeconomic quintiles is
assumed to be the same between different age/sex groups, but the average
of the deprivation-specific estimates is constrained to be the same as
the published average.

Note the varying socioeconomic gradients, e.g. breast cancer is
commonest among the least deprived, and lung cancer commonest for the
most deprived.

For some cancers (esophageal, gastric, myeloid leukemia, myeloma) the
apparent lack of socioeconomic effect is due to the assumption that this
effect is the same as for all cancers combined, which may not be true.
Perhaps this effect might be borrowed from other countries, if there is
data.

```{r}
#| fig-height: 12
ggplot(cancerinc, 
       aes(x=age, y=rate_soc, col=sex, alpha=socio)) +
       # aes(x=age, y=rate_soc, linetype=sex, colour=socio)) + 
    geom_line(lwd=1.5) + 
    geom_line(data=cancerinc_agesex,
              aes(x=age, y=rate_interp, group=sex), 
              inherit.aes = FALSE,
              lwd=1, lty=2, alpha=0.4, col="black") +
    facet_wrap(~site, ncol=2, scales="free_y") + 
    ylab("Incidence rate (per 100,000)") +
    xlab("Age (years)") +
    coord_cartesian(xlim=c(25, 90)) +
    guides(alpha=guide_legend(title=NULL),
           col=guide_legend(title=NULL)) +
    theme(legend.position = "bottom")
```

#### Illustrations of incidence estimates

***Graphs comparing, for each disease and sex, rates for Australian
average from AIHW and by socioeconomic status, age and sex from data
derived from ATLAS aggregated by socioeconomic group.***

These graphs are intended to check patterns for the data, and that these
are in the expected direction. For most cancers, data shows that low
socioeconomic groups have higher rates of incidence than high
socioeconomic groups, with low ses above the average by age and sex and
high ses below the age and sex average. There are exceptions, for
example, for breast cancer and prostate cancer, the opposite is the
case. These graphs are saved in the `inc_cancer_compare` folder. We have
source data from AIHW to check on patterns
(health/original/AIHW/cancer_socioeconomic), which is included in a
subsequent set of graphs.

```{r, echo=FALSE}

rates_compare_long <- compare_socio %>% 
  mutate(socio = factor(socio, 
                        levels = c("Most disadvantaged", "Disadvantaged", 
                                   "Middle SES", "Advantaged", 
                                   "Most advantaged", "Not classified"))) %>%
  pivot_longer(
  cols = c(rate_area_100000_ave, rate_ave_100000),
  values_to = "rate",
  names_to = "rate_type")

#%>% filter(!rate_type == "rate_soc") # removed the cancer data produced form cancer estimates by SES quintile (from Chris) to improve the readibility of the graphs. 



# Create folder if it doesn't exist
folder_path <- file.path(here("images/Melbourne/", "inc_cancer_compare"))
if (!file.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Define colors for rate types
rate_type_colors <- c("black", "red", "blue")

# Loop over each combination of site and sex
for (site_val in unique(rates_compare_long$site)) {
  for (sex_val in unique(rates_compare_long$sex)) {
    # Skip certain combinations of sex and site
    if ((sex_val == "Male" && site_val %in% c("breast cancer", "endometrial cancer")) ||
        (sex_val == "Female" && site_val == "prostate cancer")) {
      cat("Skipping graph for sex:", sex_val, "and site:", site_val, "\n\n")
      next  # Skip to the next iteration of the loop
    }
    
    cat("Processing site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    
    # Subset data for the current combination of site and sex
    plot_data <- subset(rates_compare_long, site == site_val & sex == sex_val)
    
    # Check if there are data for the current combination
    if (nrow(plot_data) > 0) {
      max_rate <- max(plot_data$rate, na.rm = TRUE)
      cat("Maximum rate:", max_rate, "\n")  # Debug print statement
      
      # Create ggplot for the current combination
      p <- ggplot(plot_data, aes(x = age, y = rate, col = rate_type)) +
        geom_line(lwd = 1, aes(linetype = NULL)) +
        scale_color_manual(values = rate_type_colors) +
        facet_wrap(~socio, scales = "free_y", ncol = 1) + # Nested facet wrap for socio-economic status
        ylab("Incidence rate (per 100,000)") +
        xlab("Age (years)") +
        coord_cartesian(xlim = c(25, 90)) +
        scale_y_continuous(breaks = seq(0, max_rate, by = 400)) +  # Adjust y-axis breaks
        guides(alpha = FALSE, col = guide_legend(title = "Rate Type")) +
        theme(legend.position = "bottom", legend.box = "horizontal", legend.box.just = "center",
              legend.margin = margin(t = 5, unit = "pt"), legend.spacing = unit(0.2, "cm"))
      
      # Save the ggplot for the current combination
      png_name <- file.path(folder_path, paste0(site_val, "_", sex_val, ".png"))
      ggsave(png_name, plot = p + labs(title = paste("| Site:", site_val, "| Sex:", sex_val)), device = "png")
    } else {
      cat("No data for site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    }
  }
}

```

Notes on comparison.

**Breast cancer (F) and prostate cancer (M) show the reverse pattern,
with most disadvantaged having lowest incidence.**

These patters are confirmed with the source data saved in
cancer_socioeonomic for incidence.

**Gastric cardia cancer (F&M) have all groups being below average.**

The population weighted estimates for males are now a little bit more
aligned, with most advantaged below average, advantage aligned with
average, middle SES and disadvantaged a bit below and most disadvantaged
a little bit above. For females it improves a bit, with advantaged group
now in line with average. Number for this cancer is small, so the
estimates for the areas would be highly uncertain based on low
observations for SA2 and also overall.

**Liver cancer (F) has all groups below average.**

It improved a bit, but still some inconsistencies. The rates for females
are a bit lower than males, there is probably some uncertainty in the
SA2 estimates. But still inconsistent with cancer_socioeconomic, which
shows, for the ASR a consistent gradient for both males and females with
decreasing rates as socio economic status increases. Rates per 100,000
are very small, also small numbers for SA2.

**Malignant melanoma (F&M) show an inconsistent pattern with most
results above average.**

As per incidence_socioeconomic, for Australia wide, the highest
socioeconmic groups have the highest rates, for both males and females.
Our data based on SA2 is inconsistent with this persons patterns for
females, with lowest ses group with highest rate and highest ses group
with lowest rate. For males, all groups, except advantage are above
average.

**Myeloid leukemia (F&M) show little differentiation between socio
economic groups.**

Same patterns, very small figures.

**Myeloma (F&M) have most groups at or below average.**

Same patterns, very small figures.

Generally, discrepancies are for cancers (or age groups) with low
numbers.

***Graphs comparing, for each disease and sex and age, rates for
Australian average from AIHW and by age and sex from data derived using
data from ATLAS aggregated by socioeconomic group to also be by age and
sex.***

These graphs are saved in the `inc_cancer_compare_ave` folder.

```{r, echo=FALSE}

rates_compare_long <- compare_age_sex %>% 
  pivot_longer(
  cols = c(rate_area_100000_av_age_sex, rate_ave_100000),
  values_to = "rate",
  names_to = "rate_type")


# Create folder if it doesn't exist
folder_path <- file.path(here("images/Melbourne/", "inc_cancer_compare_ave"))
if (!file.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Define colors for rate types
rate_type_colors <- c("black", "red", "blue")

for (site_val in unique(rates_compare_long$site)) {
  for (sex_val in unique(rates_compare_long$sex)) {
    if ((sex_val == "Male" && site_val %in% c("breast cancer", "endometrial cancer")) ||
        (sex_val == "Female" && site_val == "prostate cancer")) {
      cat("Skipping graph for sex:", sex_val, "and site:", site_val, "\n\n")
      next
    }

    cat("Processing site:", site_val, "and sex:", sex_val, "\n")
    
    plot_data <- subset(rates_compare_long, site == site_val & sex == sex_val)
    
    if (nrow(plot_data) > 0) {
      max_rate <- max(plot_data$rate, na.rm = TRUE)
      cat("Maximum rate:", max_rate, "\n")

      p <- ggplot(plot_data, aes(x = age, y = rate, col = rate_type)) +
        geom_line(lwd = 1) +
        scale_color_manual(values = rate_type_colors) +
        ylab("Incidence rate (per 100,000)") +
        xlab("Age (years)") +
        coord_cartesian(xlim = c(25, 90)) +
        scale_y_continuous(
          limits = c(0, max_rate + 50),
          breaks = scales::pretty_breaks(n = 5)
        ) +
        guides(alpha = FALSE, col = guide_legend(title = "Rate Type")) +
        theme(
          legend.position = "bottom", 
          legend.box = "horizontal", 
          legend.box.just = "center",
          legend.margin = margin(t = 5, unit = "pt"), 
          legend.spacing = unit(0.2, "cm")
        )

      png_name <- file.path(folder_path, paste0(site_val, "_", sex_val, ".png"))
      ggsave(png_name, plot = p + labs(title = paste("| Site:", site_val, "| Sex:", sex_val)), device = "png")
    } else {
      cat("No data for site:", site_val, "and sex:", sex_val, "\n")
    }
  }
}
```

Notes on comparison

**Liver cancer (F&M)**

Dissagregated data (based on ATLAS) shows lower rates by age and sex
than original AIHW age and sex interpolated data.

**Malignant melanoma (F&M)**

After age 60, inconsistencies of dissagreagated (ATLAS) data below
original AIHW age and sex data.

Generally, discrepancies are for cancers (or age groups) with low
numbers.

***Graphs comparing, for each disease and sex and age, rates from AIHW
and Atlas socioeconomic data.***

Each graph created below for each site and sex combinations depicts five
graphs within representing each socioeconomic group, and within each
graph by socioeconomic group a line called rate which represents the
rate by age and sex for Australia wide from AIHW data (rate_ave), the
rate derived from age and sex and age standardised rates by
socioeconomic group from AIHW data (rate_AIHW) and rate derived from
ATLAS data by sex and SA2 and rates by age and sex (rate_Atlas). These
graphs are saved in the `inc_cancer_compare_atlas_aihw_soc` folder.

```{r}
rates_compare_long <- compare_socio %>% 
  mutate(socio = factor(socio, 
                        levels = c("Most disadvantaged", "Disadvantaged", 
                                   "Middle SES", "Advantaged", 
                                   "Most advantaged", "Not classified"))) %>%
  rename(rate_ave = rate_ave_100000,
         rate_AIHW = rate_soc,
         rate_Atlas = rate_area_100000_ave) %>%
  pivot_longer(
    cols = c(rate_ave, rate_AIHW, rate_Atlas),
    values_to = "rate",
    names_to = "rate_type"
)

# Create folder if it doesn't exist
folder_path <- file.path(here("images/Melbourne/", "inc_cancer_compare_atlas_aihw_soc"))
if (!file.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}
# Define colors for rate types
rate_type_colors <- c("black", "red", "blue")
# Loop over each combination of site and sex
for (site_val in unique(rates_compare_long$site)) {
  for (sex_val in unique(rates_compare_long$sex)) {
    # Skip certain combinations of sex and site
    if ((sex_val == "Male" && site_val %in% c("breast cancer", "endometrial cancer")) ||
        (sex_val == "Female" && site_val == "prostate cancer")) {
      cat("Skipping graph for sex:", sex_val, "and site:", site_val, "\n")
      next  # Skip to the next iteration of the loop
    }
    
    cat("Processing site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    
    # Subset data for the current combination of site and sex
    plot_data <- subset(rates_compare_long, site == site_val & sex == sex_val)
    
    # Check if there are data for the current combination
    if (nrow(plot_data) > 0) {
      max_rate <- max(plot_data$rate, na.rm = TRUE)
      cat("Maximum rate:", max_rate, "\n")  # Debug print statement
      
      # Create ggplot for the current combination
      p <- ggplot(plot_data, aes(x = age, y = rate, col = rate_type)) +
        geom_line(lwd = 1, aes(linetype = NULL)) +
        scale_color_manual(values = rate_type_colors) +
        facet_wrap(~socio, scales = "free_y", ncol = 1) + # Nested facet wrap for socio-economic status
        ylab("Incidence rate (per 100,000)") +
        xlab("Age (years)") +
        coord_cartesian(xlim = c(25, 90)) +
        scale_y_continuous(breaks = seq(0, max_rate, by = 500)) +  # Adjust y-axis breaks
        guides(alpha = FALSE, col = guide_legend(title = "Rate Type")) +
        theme(legend.position = "bottom", legend.box = "horizontal", legend.box.just = "center",
              legend.margin = margin(t = 5, unit = "pt"), legend.spacing = unit(0.2, "cm"))
      
      # Save the ggplot for the current combination
      png_name <- file.path(folder_path, paste0(site_val, "_", sex_val, ".png"))
      ggsave(png_name, plot = p + labs(title = paste("| Site:", site_val, "| Sex:", sex_val)), device = "png")
    } else {
      cat("No data for site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    }
  }
}

```

Notes on comparison of data sources

In general, rates calculated with AIHW data and rates derived from ATLAS
data are very similar, with small discrepancies for cancer with small
incidence rates.

-   *Esophageal cancer rates for males are higher and lower respectively
    for disadvantaged and most disadvantage and most advantaged when
    using rates based on areas (ATLAS) data. Rates from socioeconomic
    status (from AIHW data) for esophageal cancer were assumed to follow
    the same patterns as all cancers.*

-   *For head and neck, rates for males and females from area rates
    (ATLAS) are more conservative than with AIHW, for example, for the
    advantaged group, area (Atlas) rates are higher than rates from
    socioeconomic data (AIHW). Similar pattern with liver cancer and
    lung cancer.*

***A last check is to calculated average standardised rate by
socioeconomic group and compare with source data from
cancer_socioeconomic.***

The output charts are saved in the `inc_cancer_compare_ASR` folder.

```{r, echo=FALSE}

# age standardised rate from ATLAS data (cancer_incidence_area)
age_standardised_rate_soc <- cancer_incidence_area %>%
  # Filter out rows where population is NA to avoid issues with the weighted mean
  filter(!is.na(population), !is.na(rate_area_100000)) %>%
  
  group_by(site, socio) %>%
  summarise(
    # Only calculate the weighted mean if both rate_area_100000 and population are available
   ASR = sum(rate_area_100000*population, na.rm=TRUE)/sum(population),
    .groups = "drop"
  )  %>%
  mutate(socio = as.factor(socio)) %>%
  filter(socio != "Not classified") %>%
 # Filter out 'Not classified' socio values
 ungroup()

# join to AIHW data from cancer_socioeconomic (cancerinc_socio)
rates_compare_long <- age_standardised_rate_soc %>%
  mutate(socio = case_when(
    socio == "Most disadvantaged" ~ 1,
    socio == "Disadvantaged"      ~ 2,
    socio == "Middle SES"         ~ 3,
    socio == "Advantaged"         ~ 4,
    socio == "Most advantaged"    ~ 5
  )) %>%
  rename(rate_Atlas = ASR) %>%
  left_join(cancerinc_socio %>%
              mutate(site = tolower(site)) %>%
              rename(rate_AIHW = rate) %>%
              dplyr::select(site, socio, rate_AIHW),
            by = c("site", "socio")) %>%
  pivot_longer(
    cols = c(rate_AIHW, rate_Atlas),
    values_to = "rate",
    names_to = "rate_source"
  )

# Create folder if it doesn't exist
folder_path <- file.path(here("images/Melbourne/", "inc_cancer_compare_ASR"))
if (!file.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

for (site_val in unique(rates_compare_long$site)) {

    cat("Processing site:", site_val, "\n")
    
    plot_data <- subset(rates_compare_long, site == site_val)
    
    if (nrow(plot_data) > 0) {
 
      p <- ggplot() + 
        geom_col(data = plot_data, 
                 aes(x = socio, y = rate, fill = rate_source),
                 position = "dodge") +
        labs(xlab = "Socioeconomic group (1 is lowest, 5 is highest)",
             ylab = "Incidence rate (per 100,000") 
 
      png_name <- file.path(folder_path, paste0(site_val, ".png"))
      ggsave(png_name, plot = p + labs(title = paste("| Site:", site_val), device = "png"))
    } else {
      cat("No data for site:", site_val, "\n")
    }
  # }
}



```

-   For most cancers (all cancers, bladder, endometrial, head and neck,
    kidney, liver, lung, malignant melanoma) the pattern of values is
    generally in the same direction in both datasets, but values from
    ATLAS generated data, aggregated by disease, are higher that those
    in the AIHW data (cancer_socioecononmic).

-   For colon and rectum cancers, the pattern of values is also in the
    same direction in both datasets, but the AIHW values are higher.
    This is because the AIHW values are for both cancers combined.

-   For breast and prostate cancers, the AHIW data shows rates
    increasing as socio-economic status increases, but the Atlas does
    not match this pattern.

-   For esophageal, gastric cardia, myeloid leukemia and myeloma
    cancers, the charts are not useful because they are comparing Atlas
    values for the specific cancer against AIHW values for all cancers.

#### Clean and save data

The final cancer incidence data (using socioeconomic data from the
Cancer Atlas) is saved as `cancer_incidence_final.rds`.

```{r}
cancer_incidence_area <- cancer_incidence_area %>%
  rename(cause = site) %>%
  mutate(measure = "incidence") %>%
  select(sa2_code, sa2_name, socio, cause, measure, age, sex, prob, rate = rate_area) %>%
  mutate(socio = as.numeric(case_when(
    socio == "Most disadvantaged" ~ 1,
    socio == "Disadvantaged" ~ 2,
    socio == "Middle SES" ~ 3, 
    socio == "Advantaged" ~ 4,
    socio == "Most advantaged"  ~ 5,
    TRUE ~ NA_real_  # Assign NA for non-classified
  ))) %>%
  filter(!is.na(socio)) # Now filtering for non-classified values
  
# Use 9 digits sa2 codes for compatibility with synthetic population

areas <- read.csv(here("melbourne/health/original/ABS/SA2_2016_AUST.csv")) %>%
  select(c("SA2_MAINCODE_2016", "SA2_5DIGITCODE_2016")) %>%
  rename(sa2_code = SA2_5DIGITCODE_2016)
  
cancer_incidence_area <- cancer_incidence_area %>% left_join(areas) %>%
  select(!sa2_code) %>%
  rename(sa2_code = SA2_MAINCODE_2016) %>%
  mutate(sa2_code = as.numeric(sa2_code))

saveRDS(cancer_incidence_area, file=here("melbourne/health/processed/cancer_incidence_final.rds"))

```

### Cardiovascular diseases, dementia, type 2 diabetes and COPD

This script produces estimates of incidence for stroke, ischemic heart
disease, dementia, type 2 diabetes and chronic obstructive pulmonary
disease (COPD) by age, sex and area socioeconomic quintile, for
Australia using data for 2016 and 2018.

The data is obtained from the Global Burden of Disease for disease
incidence by age and sex and from AIHW by sex and socioeconomic status
(JIBE data summary spreadsheet). There is no unique source of data for
what we need, hence the combination of data sources. Source files:

Incidence by 5-year age group and sex for stroke, ischemic heart disease
and type 2 diabetes:

-   `gbd_incidence.csv` (available from GBD data tool, data is for 2018,
    baseline year for the jibe model)

Incidence, death and prevalence by sex and socioeconomic area for 2016
(stroke, ischemic heart disease and type 2 diabetes) or 2021 (dementia
and COPD). We do not have data for incidence by socioeconomic area for
all diseases of interest, hence, we use deaths and prevalence, depending
which one is more suitable.

We do not have data by socioeconomic status for depression.

-   `cvd_dia_kid_socioeconomic.xlsx`, which contains:

    -   *Stroke incidence: by sex and socioeconomic area for 2016: Table
        S2*

    -   *Cardiovascular disease death: by sex and socioeconomic area for
        2016: Table S3*

    -   *Type 2 diabetes prevalence: by sex and socioeconomic area for
        2016: Table S7*

-   `dementia-mortality-xlsx`, which contains *Deaths due to dementia in
    2021: age-standardised and crude rates by sex and geographic and
    socioeconomic areas: Table S3.6*

-   `copd-mortality.xlsx`, which contains *Respiratory mortality
    statistics, by remoteness area and SEIFA-quintile, 2021: Table
    Resp_Mort.2*

These data refer to the whole of Australia, and we do not have area
specific data (e.g. SA2 as we do with mortality). These data are
combined to produce estimates for each of stroke, ischemic heart
disease, dementia, type 2 diabetes and COPD by age, sex and area
socioeconomic quintile. This assumes that the effect of socioeconomic
status on the incidence of these diseases is the same for all age and
sex groups.

#### Incidence by age and sex

Data by year of age is interpolated as above.

```{r}
inc_cvd_dem_dia_copd_agesex <- gbdpyr %>%
  filter (cause %in% c("Stroke", "Ischemic heart disease", 
                       "Alzheimer's disease and other dementias",
                       "Diabetes mellitus type 2",
                       "Chronic obstructive pulmonary disease")) %>%
  dplyr::select(cause, age = ageyr, sex, rate = val_interpolated)

```

#### Incidence by socioeconomic status and sex

-   Socioeconomic areas are classified according to population-based
    quintiles using the Index of Relative Socio-Economic Disadvantage
    (IRSD) based on Statistical Area Level 2 (SA2) of usual residence.
-   The below data sources are then used to adjust GBD data by age and
    sex to also be further dissaggregated by socioeconomic status.

```{r}
# Stroke

stroke_inc <- read_xlsx(here("melbourne/health/original/AIHW/cdv_dia_kid_socioeconomic.xlsx"), sheet="Table S2", skip=1, col_names = TRUE, n_max=30) %>%
  slice(-c(7:11, 18:26)) %>%
  mutate(sex = ifelse(row_number() <= 7, "Male", "Female")) %>%
  slice(-c(1,7)) %>%
  rename(socio=`Socioeconomic group`, 
         rate=`2016`) %>%
  mutate(socio = case_when(socio=="Group 1 (lowest)" ~ "1", # 1: lowest, to 5: highest
                           socio=="Group 2" ~ "2",
                           socio=="Group 3" ~ "3",
                           socio=="Group 4" ~ "4",
                           socio=="Group 5 (highest)" ~ "5",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) |> 
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause="Stroke") # to match gbd name

# Cardiovascular disease (data is for deaths for CVDs, we will use it to adjust CHD/IHD incidence by age and sex)

cvd_inc <- read_xlsx(here("melbourne/health/original/AIHW/cdv_dia_kid_socioeconomic.xlsx"), sheet="Table S3", skip=1, col_names = TRUE, n_max=30) %>%
  slice(-c(7:11, 18:26)) %>%
  mutate(sex = ifelse(row_number() <= 7, "Male", "Female")) %>%
  slice(-c(1,7)) %>%
  rename(socio=`Socioeconomic group`, 
         rate=`2016`) %>%
  mutate(socio = case_when(socio=="Group 1 (lowest)" ~ "1", # 1: lowest, to 5: highest
                           socio=="Group 2" ~ "2",
                           socio=="Group 3" ~ "3",
                           socio=="Group 4" ~ "4",
                           socio=="Group 5 (highest)" ~ "5",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) |> 
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause="Ischemic heart disease") # to match gbd name


# Dementia (we use mortality data.  There is also hospitalisation data (dementia-hospital-care.xlsx, Table S9.6), but the socioeconomic area rates for hospitalisations are not differentiated by sex, whereas the mortality data shows  greater socioeconomic area variation for Females than Males.)

dementia_inc <- read_xlsx(here("melbourne/health/original/AIHW/dementia-mortality.xlsx"), 
                          sheet = "S3.6", skip = 8, col_names = TRUE, n_max = 5) %>%
  rename_with( ~ c("category", "socio", "Male", "Female", "Person",
                   "MaleCrude", "FemaleCrude", "PersonCrude")) %>%
  dplyr::select(socio, Female, Male) %>%
  pivot_longer(cols = c("Female", "Male"), names_to = "sex", values_to = "rate") %>%
  mutate(socio = case_when(socio == "1 (lowest)" ~ "1", # 1: lowest, to 5: highest
                           socio == "5 (highest)" ~ "5",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  arrange(socio) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) |> 
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause = "Alzheimer's disease and other dementias") # to match gbd name


# Diabetes (we use prevalence data. There is mortality data, but figures are low and diabetes as cause of deaths is likely under reported)

diabetes_inc <- read_xlsx(here("melbourne/health/original/AIHW/cdv_dia_kid_socioeconomic.xlsx"), sheet="Table S7", skip=1, col_names = TRUE, n_max=30) %>%
  slice(-c(7:11, 18:27)) %>%
  mutate(sex = ifelse(row_number() < 7, "Male", "Female")) %>%
  slice(-c(1, 7)) %>%
  rename(socio=`Socioeconomic group`, 
         rate=`2016`) %>%
  mutate(socio = case_when(socio=="Group 1 (lowest)" ~ "1", # 1: lowest, to 5: highest
                           socio=="Group 2" ~ "2",
                           socio=="Group 3" ~ "3",
                           socio=="Group 4" ~ "4",
                           socio=="Group 5 (highest)" ~ "5",
                           socio =="Total" ~ "6",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) |>
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause="Diabetes mellitus type 2") #to match gbd name


# COPD (we use mortality data.  There is prevalence data, but it is self-reported.)

copd_inc <- read_xlsx(here("melbourne/health/original/AIHW/copd-mortality.xlsx"),
            sheet = "Table Resp_Mort.2", skip = 4, col_names = TRUE) %>%
    filter(str_detect(Geography, "SEIFA")) %>%
  filter(Year == "2021" &  # SEIFA table only has 2021
           Condition == "Respiratory - COPD" &
           `Cause scope` == "1. Underlying cause of condition" &
           Sex %in% c("Females", "Males")) %>%
  dplyr::select(socio = Geography, sex = Sex, 
                rate = `Deaths per 100,000 population (age standardised)`) %>%
  mutate(socio = case_when(
    socio == "SEIFA-2016 Quintile 1 (most disadvantaged)"  ~ "1", # 1: lowest, to 5: highest
    socio == "SEIFA-2016 Quintile 2"                       ~ "2",
    socio == "SEIFA-2016 Quintile 3"                       ~ "3",
    socio == "SEIFA-2016 Quintile 4"                       ~ "4",
    socio == "SEIFA-2016 Quintile 5 (least disadvantaged)" ~ "5",
    .default = socio),
    socio = as.numeric(socio),
    sex = case_when(sex == "Females" ~ "Female",
                    sex == "Males"   ~ "Male",
                    .default = sex)) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) %>%
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause="Chronic obstructive pulmonary disease") # to match gbd name


# Combined database with all four diseases

inc_cvd_dem_dia_copd_socio <- bind_rows(cvd_inc, dementia_inc, diabetes_inc, 
                                        stroke_inc, copd_inc) %>% 
  arrange(cause, sex, socio)

```

#### Combining socioeconomic status with age and sex

We use the method outlined in `Inequalities in health` above to
disaggregate the age and sex data by socioeconomic status.

```{r}
cvd_dem_dia_copd_inc <- inc_cvd_dem_dia_copd_agesex %>% 
    slice(rep(row_number(), each=5)) %>%
    mutate(socio = rep(1:5, length.out=n())) %>%
    left_join(inc_cvd_dem_dia_copd_socio %>% select(cause, sex, socio, rr_socio = rr), 
              by = c("cause", "sex", "socio")) %>%
    mutate(p_socio = 1/5,    # assumption
           pRR = p_socio * rr_socio,
           socio = ordered(socio))

sum_p <- cvd_dem_dia_copd_inc %>% 
    group_by(cause, age, sex) %>%
    summarise(sum_pRR = sum(pRR), .groups="drop")
    
cvd_dem_dia_copd_inc <- cvd_dem_dia_copd_inc %>%
    left_join(sum_p, by=c("cause", "age", "sex")) %>%
    mutate(rate_soc = rate * rr_socio / sum_pRR, 
           socio = ordered(socio, labels = c("1 (most deprived)",
                                             "2","3","4",
                                             "5 (least deprived)")),
           sex = factor(sex), 
           prob=1 - exp(-rate_soc))

```

We are left with the incidence by age, sex and socioeconomic status in
the variable `rate_soc`.

#### Illustration of incidence estimates

Incidence by age, sex and socioeconomic quintile for ischemic heart
disease, stroke, dementia, type 2 diabetes and COPD.

The published incidence by age and sex (averaged over deprivation
levels) is shown by the dotted black lines (original gbd data
interpolated from 5 year age groups to one year). The estimated
incidence disaggregated by socioeconomic quintile is shown by the
coloured lines, with socioeconomic status indicated by the lightness of
the lines (calculated from gbd data and aihw data).

The relative risk between socioeconomic quintiles is assumed to be the
same between different age/sex groups, but the average of the
deprivation-specific estimates is constrained to be the same as the
published average.

The plots are saved in the folder `inc_cvd_dem_dia_copd`.

All plots show the expected outcome of the highest levels of incidence
at the highest levels of disadvantage, though the pattern is less
obvious for dementia, particularly for males.

```{r}
# plot of data
p <- ggplot(cvd_dem_dia_copd_inc, 
       aes(x=age, y=rate_soc, col=sex, alpha=socio)) + 
    geom_line(lwd=1.5) + 
    geom_line(data=inc_cvd_dem_dia_copd_agesex,
              aes(x=age, y=rate, group=sex), 
              inherit.aes = FALSE,
              lwd=1, lty=2, alpha=0.4, col="black") +
    facet_wrap(~cause, ncol=2, scales="free_y") +
    ylab("Incidence rate (per 100,000)") +
    xlab("Age (years)") +
    coord_cartesian(xlim=c(25, 90)) +
    guides(alpha=guide_legend(title=NULL),
           col=guide_legend(title=NULL)) +
    theme(legend.position = "bottom")

# save plot
# Generate and save all pages
output_dir <- file.path(here("images/Melbourne/inc_cvd_dem_dia_copd/"))
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

ggsave(filename = paste0(output_dir, "/cvd_dem_dia_copd_incidence.png"), plot = p, 
       width = 12, height = 12, bg = "white")

```

#### Clean and save data

The final incidence data for non-cancers is saved as
`cvd_dem_dia_copd_incidence_final.rds`.

```{r}

cvd_dem_dia_copd_inc <- cvd_dem_dia_copd_inc %>% 
  select(socio, cause, age, sex, prob, rate = rate_soc) %>% 
  mutate(measure="incidence")  %>%
  mutate(socio=as.numeric(socio)) %>% 
  mutate(sex=as.character(sex))


saveRDS(cvd_dem_dia_copd_inc, file=(here("melbourne/health/processed/cvd_dem_dia_copd_incidence_final.rds")))
```

# Prevalence data

We need prevalence probabilities for the baseline year 2018, to randomly
assign who starts the simulation and is diseased. Second, we need
prevalent data for years after (standardised rates, numbers), We need to
calibrate the model and validate, so more than one data source would be
great.

**STEVE, the below data processing provides baselines year data. Can you
please get prevalent data for later years and save it in a different
file?**

## Prevalence data by age and sex

We use GBD data as the age and sex data for prevalence estimates.

### Global Burden of disease data for Australia: data interpolation

Interpolated prevalence data by sex and single year of age has been
prepared under 'Incidence data' above. Graphs are created and saved in
docs/images/prev_gbd_age_sex to visually check the fit of the
interpolation to the original data.

```{r}
# Extract the prevalence values from the interpolated GDB data prepared above and plot the 2018 values
gbdpyr <- gbdpyr_interp %>%
  filter(measure == "Prevalence")

# Melt the data to long format for ggplot
plot_data <- gbdpyr %>%
  filter(year == 2018) %>%
  select(measure, cause, sex, ageyr, rate_1, val_interpolated) %>%
  pivot_longer(cols = c(rate_1, val_interpolated), names_to = "type", values_to = "value")

# Generate and save all pages
# output_dir <- "docs/images/prev_gbd_age_sex_smooth_spline/"
# output_dir <- "docs/images/prev_gbd_age_sex_spline/"
# output_dir <- "docs/images/prev_gbd_age_sex_loess/"
# output_dir <- "docs/images/prev_gbd_age_sex_polynomial/"
output_dir <- file.path(here("images/Melbourne/prev_gbd_age_sex_smooth/"))
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

plot_interpolation_pages(plot_data, output_dir)
```

### Prevalence by age and sex, with adjustments for specific diseases

Some specific cancers need adjustment to match GBD data to standardised
JIBE disease list. Apart from name changes, the following cancers need
transformation:

-   Head and neck cancer: sum of Larynx cancer + Lip and oral cavity
    cancer + Nasopharynx cancer + Other pharynx cancer

-   Colon cancer, Rectum cancer: Colon and rectum cancer, apportioned
    based on AIHW incidence rates

-   Lung cancer: Tracheal, bronchus, and lung cancer, apportioned based
    on comparison of AIHW incidence rates for Lung cancer and GBD
    incidence rates for Tracheal, bronchus, and lung cancer

```{r}

prev_agesex_all <- gbdpyr %>%
  filter (cause %in% c("Stroke", "Ischemic heart disease", "Breast cancer", 
                       "Uterine cancer", "Tracheal, bronchus, and lung cancer", 
                       "Colon and rectum cancer", "Esophageal cancer", 
                       "Liver cancer", "Kidney cancer", 
                       "Stomach cancer", "Chronic myeloid leukemia", "Multiple myeloma", 
                       "Larynx cancer", "Lip and oral cavity cancer", "Nasopharynx cancer",
                       "Other pharynx cancer", "Bladder cancer", "Prostate cancer", 
                       "Malignant skin melanoma", "Depressive disorders", 
                       "Major depressive disorder", "Alzheimer's disease and other dementias", 
                       "Diabetes mellitus type 2", "Chronic obstructive pulmonary disease")) %>%
  dplyr::select(year, cause, age = ageyr, sex, rate = val_interpolated) %>%
  mutate(cause = case_when(
    cause == "Ischemic heart disease"    ~ "Coronary heart disease",
    cause == "Uterine cancer"            ~ "Endometrial cancer",
    cause == "Stomach cancer"            ~ "Gastric cardia cancer",
    cause == "Chronic myeloid leukemia"  ~ "Myeloid leukemia",
    cause == "Multiple myeloma"          ~ "Myeloma",
    cause == "Malignant skin melanoma"   ~ "Malignant melanoma",
    cause == "Major depressive disorder" ~ "Major depression",
    cause == "Alzheimer's disease and other dementias" ~ "All cause dementia",
    cause == "Diabetes mellitus type 2"  ~ "Diabetes type 2",
    .default = cause
  ))


# sum rates for head an neck cancers
hanc <- c("Larynx cancer", "Lip and oral cavity cancer", "Nasopharynx cancer",
          "Other pharynx cancer")
prev_agesex_hanc <- prev_agesex_all %>%
  filter(cause %in% hanc) %>%
  group_by(year, sex, age) %>%
  summarise(rate = sum(rate), .groups = "drop") %>%
  mutate(cause = "Head and neck cancer")

prev_agesex_all <- prev_agesex_all %>%
  filter(!cause %in% hanc) %>%
  bind_rows(prev_agesex_hanc)


# split rates for colon and rectum cancers by reference to the AIHW incidence
# rates for those two diseases
# AIHW incidence proportions for colon and rectum cancer
inc_crc <- incyr %>% 
  filter(site %in% c("colon cancer", "rectum cancer")) %>%
  dplyr::select(site, sex, ageyr, rate_1) %>%
  mutate(site = case_when(site == "colon cancer"  ~ "colon",
                          site == "rectum cancer" ~ "rectum"),
         sex = case_when(sex == "Females" ~ "Female",
                         sex == "Males"   ~ "Male")) %>%
  pivot_wider(names_from = site, values_from = rate_1) %>%
  # total of the two rates (with small constant to avoid zeros)
  mutate(total = colon + rectum) %>%
  mutate(total = ifelse(total == 0, 1e-6, total)) %>%
  # proportions
  mutate(colon_prop = colon/total,
         rectum_prop = rectum/total) %>%
  dplyr::select(sex, age = ageyr, colon_prop, rectum_prop)

# apportion colon and rectum cancer by rates
prev_agesex_crc <-
  prev_agesex_all %>%
  filter(cause == "Colon and rectum cancer") %>%
  # join the proportions and calculate proportionate rates
  left_join(inc_crc, by = c("sex", "age")) %>%
  mutate(Colon = rate * colon_prop,
         Rectum = rate * rectum_prop) %>%
  # pivot into separate rows for colon and rectum
  dplyr::select(year, age, sex, Colon, Rectum) %>%
  pivot_longer(cols = c("Colon", "Rectum"), names_to = "cause",
               names_transform = ~ paste(., "cancer"),
               values_to = "rate")

prev_agesex_all <- prev_agesex_all %>%
  filter(!cause == "Colon and rectum cancer") %>%
  bind_rows(prev_agesex_crc)
  

# lung cancer: use incidence numbers from AIHW (lung) and GBD (tracheal, bronchus
# and lung) to determine a proportion for lung, and apply to GBD prevalence (tracheal,
# bronchus and lung)
lung_proportion <- incyr_interp %>%  # AIHW incidence - use 2018 to match GBD
  filter(year == 2018 & site == "lung cancer") %>%
  mutate(sex = case_when(sex == "Females" ~ "Female", sex == "Males" ~ "Male")) %>%
  dplyr::select(sex, ageyr, lung_val = val_interpolated) %>%
  left_join(gbdpyr_interp %>%  # GBD incidence for 2018
              filter(measure == "Incidence" & year == 2018) %>%
              filter(cause == "Tracheal, bronchus, and lung cancer") %>%
              dplyr::select(sex, ageyr, tbalc_val = val_interpolated),
            by = c("sex", "ageyr")) %>%
  mutate(lung_prop = lung_val / tbalc_val)

# plot the respective rates
ggplot(lung_proportion %>%
         rename(lung_val_AIHW = lung_val, tbalc_val_GBD = tbalc_val) %>%
         pivot_longer(cols = c("lung_val_AIHW", "tbalc_val_GBD"), 
                      names_to = "site", values_to = "value") %>%
         mutate(sex_site = paste0(sex, "_", site))) +
  geom_line(aes(x = ageyr, y = value, colour = sex_site), lwd = 1) +
  scale_color_brewer(palette = "Paired") +
  labs(title = "AIHW lung cancer incidence vs GBD tbalc incidence",
       x = "Age (years)",
       y = "Incidence rate (per 100,000)") +
  theme_minimal()
  
# multiply tbalc_rate by lung_prop to get lung rate - but some years have higher 
# lung than tbalc, so in that case just use the tbalc figure
prev_agesex_lung <- prev_agesex_all %>%
  filter(cause == "Tracheal, bronchus, and lung cancer") %>%
  rename(tbalc_rate = rate) %>%
  left_join(lung_proportion %>%
              dplyr::select(sex, age = ageyr, lung_prop),
            by = c("sex", "age")) %>%
  mutate(rate = ifelse(lung_prop < 1, tbalc_rate * lung_prop, tbalc_rate)) %>%
  dplyr::select(-tbalc_rate, -lung_prop) %>%
  mutate(cause = "Lung cancer")

prev_agesex_all <- prev_agesex_all %>%
  filter(!cause == "Tracheal, bronchus, and lung cancer") %>%
  bind_rows(prev_agesex_lung)

# filter to 2018 values
prev_agesex <- prev_agesex_all %>%
  filter(year == 2018) %>%
  dplyr::select(-year)
  

```

## Inequalities

We disaggregate the above age and sex data by socioeconomic status, to
represent inequalities in health, where data is available. In some cases
data for prevalence by socioeconomic status is not available or
appropriate, and in those cases we use data for incidence or mortality.

The data used is as follows.

-   Cancers: `ATLAS/Atlas_estimates_95CIs.xlsx`. This is incidence data
    from the Cancer Atlas, by SA2 area (including socioeconomic
    quintile) and sex, as described under 'Incidence data'.

-   Stroke and Coronary heart disease:
    `AIHW/cvd-diabetes-comorbidities.xlsx`, Tables 'Stroke Table 2' and
    'CHD Table 2'. This is prevalence data from AIHW, by socioeconomic
    quintile and sex, for 2017-18.

-   Dementia: `AIHW/dementia-mortality.xlsx`, Table S3.6. This is
    mortality data from AIHW, by socioeconomic quintile and sex, for

    2021. 

-   Diabetes type 2: `AIHW/cdv_dia_kid_socioeconomic.csv`, Table S7.
    This is prevalence data from AIHW, by socioeconomic quintile and
    sex, for 2016.

-   Chronic obstructive pulmonary disease: `AIHW/copd-mortality.xlsx`,
    Table Resp_Mort.2. This is mortality data from AIHW, by
    socioeconomic quintile and sex, for 2021.

We did not identify relevant socioeconomic data for Depressive disorders
or Major depression.

### Cancers

We use socioeconomic incidence data from the Cancer Atlas (see source
above), processed in the same way as described in section 2.2 above for
incidence, but applied to the age and sex prevalence data from GBD
rather than the age and sex incidence data from AIHW. The resulting
output table is saved as `health/processed/cancer_prevalence_area.rds`,
and output plots are saved in the \`docs/images/prev_cancer' folder.

```{r}
# Cancers, using 'data_sa2_sex_age' as calculated for incidence, 
# combined with prevalence data by age and sex

# combine
prev_sa2_sex_age <- data_sa2_sex %>% 
  mutate(site = str_to_sentence(site),
         sex = case_when(sex == "Females" ~ "Female",
                         sex == "Males"   ~ "Male")) %>%
  filter(site %in% prev_agesex$cause) %>%
  left_join(prev_agesex, by=c("sex", c("site" = "cause"))) %>%
  filter(!is.na(rate)) %>%  # omitting where no rate (male endometrial cancer)
  mutate(rate_area=as.numeric(SIR)*rate) %>%
  rename(socio=`Socioeconomic index`) 

# finalise and save
cancer_prevalence_area <- prev_sa2_sex_age %>% 
  rename (sa2_code = `SA2 code`, sa2_name = SA2) %>%
  mutate(prob = 1 - exp(-rate_area)) %>%
  select(sa2_code, sa2_name, socio, site, age, sex, prob, rate_area, val_interpolated = rate) %>%
  mutate(rate_ave_age_sex = val_interpolated * 100000)

saveRDS(cancer_prevalence_area, file=here("melbourne/health/processed/cancer_prevalence_area.rds"))

```

#### Illustration of prevalence estimates

Each graph created below for each site and sex combinations depicts five
graphs within representing each socioeconomic group, and within each
graph by socioeconomic group a line called rate_ave_agae_sex which
represents the rate by age and sex for Australia wide (black), and a
line called rate_area which is the rate derived from data by sex and SA2
and rates by age and sex (red).

Most graphs show the expected pattern of most disadvantaged having
incidence above average through to most advantaged having incidence
below average. Following are the exceptions:

-   breast cancer (F) and prostate cancer (M) show the reverse pattern,
    with most disadvantaged having lowest incidence.
-   gastric cancer (F&M) have all groups being below average.
-   liver cancer (F) has all groups below average.
-   malignant melanoma (F&M) show an inconsistent pattern with most
    results above average.
-   myeloid leukemia (F&M) show little differentiation between socio
    economic groups.
-   myeloma (F&M) have most groups at or below average.

These are the same exceptions as were identified above for cancer
incidence (not surprisingly, as the same Cancer Atlas socioeconomic
incidence data is applied to both incidence and prevalence figures by
sex and age).

```{r}
## take mean of groups by socio area, and summarise
cancer_prev_socio <- cancer_prevalence_area %>%
  group_by(age, sex, site, socio, rate_ave_age_sex) %>%
  summarise(rate_area = round(mean(rate_area, na.rm = TRUE), 7), .groups = "drop") %>% 
  filter(socio != "Not classified") %>%
  mutate(socio = factor(socio, 
                        levels = c("Most disadvantaged", "Disadvantaged", 
                                   "Middle SES", "Advantaged", 
                                   "Most advantaged", "Not classified"))) %>%
  mutate(rate_area = rate_area * 100000) %>%
  na.omit(.) %>%  # omit na values, eg female prostate cancer
  #pivot longer
  pivot_longer(cols = c(rate_area, rate_ave_age_sex),
               values_to = "rate", names_to = "rate_type")


# Create folder if it doesn't exist
folder_path <- file.path(here("images/Melbourne/", "prev_cancer_compare"))
if (!file.exists(folder_path)) {
  dir.create(folder_path, recursive = TRUE)
}

# Define colors for rate types
rate_type_colors <- c("black", "red")

# Loop over each combination of site and sex
for (site_val in unique(cancer_prev_socio$site)) {
  for (sex_val in unique(cancer_prev_socio$sex)) {
    # Skip certain combinations of sex and site
    if ((sex_val == "Male" && site_val %in% c("Breast cancer", "Endometrial cancer")) ||
        (sex_val == "Female" && site_val == "Prostate cancer")) {
      cat("Skipping graph for sex:", sex_val, "and site:", site_val, "\n\n")
      next  # Skip to the next iteration of the loop
    }
    
    cat("Processing site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    
    # Subset data for the current combination of site and sex
    plot_data <- subset(cancer_prev_socio, site == site_val & sex == sex_val)
    
    # Check if there are data for the current combination
    if (nrow(plot_data) > 0) {
      max_rate <- max(plot_data$rate, na.rm = TRUE)
      cat("Maximum rate:", max_rate, "\n")  # Debug print statement
      
      # Create ggplot for the current combination
      p <- ggplot(plot_data, aes(x = age, y = rate, col = rate_type)) +
        geom_line(lwd = 1, aes(linetype = NULL)) +
        scale_color_manual(values = rate_type_colors) +
        facet_wrap(~socio, scales = "free_y", ncol = 1) + # Nested facet wrap for socio-economic status
        ylab("Incidence rate (per 100,000)") +
        xlab("Age (years)") +
        coord_cartesian(xlim = c(25, 90)) +
        scale_y_continuous(breaks = seq(0, max_rate, by = 400)) +  # Adjust y-axis breaks
        guides(alpha = FALSE, col = guide_legend(title = "Rate Type")) +
        theme(legend.position = "bottom", legend.box = "horizontal", legend.box.just = "center",
              legend.margin = margin(t = 5, unit = "pt"), legend.spacing = unit(0.2, "cm"))
      
      # Save the ggplot for the current combination
      png_name <- file.path(folder_path, paste0(site_val, "_", sex_val, ".png"))
      ggsave(png_name, plot = p + labs(title = paste("| Site:", site_val, "| Sex:", sex_val)), device = "png")
    } else {
      cat("No data for site:", site_val, "and sex:", sex_val, "\n")  # Debug print statement
    }
  }
}
```

```{r}
cancer_prevalence_area <-  cancer_prevalence_area %>%
  mutate(measure="prevalence") %>% 
  mutate(socio = as.numeric(case_when(
    socio == "Most disadvantaged" ~ 1,
    socio == "Disadvantaged" ~ 2,
    socio == "Middle SES" ~ 3, 
    socio == "Advantaged" ~ 4,
    socio == "Most advantaged"  ~ 5,
    TRUE ~ NA_real_  # Assign NA for non-classified
  ))) %>%
  filter(!is.na(socio)) %>% 
  rename(cause = site) %>% # Now filtering for non-classified values
  select(sa2_code, sa2_name, socio, cause, measure, age, sex, prob, rate = rate_area) 


```

### Other diseases

We use socioeconomic prevalence or mortality data for stroke, coronary
heart disease, dementia, diabetes and COPD from AIHW (see sources
above), processed in a similar way to that described in section 2.2
above for incidence, but applying the socioeconomic prevalence data from
AIHW to the age and sex prevalence data from GBD. The resulting output
table is saved as `health/processed/cvd_dia_copd_prevalence.rds`, and
output plots are saved in the \`docs/images/prev_cvd_dem_dia_copd'
folder.

```{r}
# Stroke
stroke_prev <- read_xlsx(here("melbourne/health/original/AIHW/cvd-diabetes-comorbidities.xlsx"),
            sheet = "Stroke", skip = 30, col_names = TRUE, n_max = 6) %>%
    slice(-1) %>%
    rename_with( ~ c("socio", "MaleNo", "FemaleNo", "PersonNo", "blank1",
                     "MaleCrudeRate", "MaleCrudeCI", "FemaleCrudeRate", "FemaleCrudeCI",
                     "PersonCrudeRate", "PersonCrudeCI", "blank2",
                     "Male", "MaleCI", "Female", "FemaleCI", "Person", "PersonCI")) %>%
    dplyr::select(socio, Male, Female) %>%
  pivot_longer(cols = c("Male", "Female"), names_to = "sex") %>%
  rename(rate = value) %>%
  mutate(socio = case_when(socio=="Group 1 (lowest)" ~ "1", # 1: lowest, to 5: highest
                           socio=="Group 2" ~ "2",
                           socio=="Group 3" ~ "3",
                           socio=="Group 4" ~ "4",
                           socio=="Group 5 (highest)" ~ "5",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  arrange(socio) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) |>
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause = "Stroke")

# Coronary heart disease
chd_prev <- read_xlsx(here("melbourne/health/original/AIHW/cvd-diabetes-comorbidities.xlsx"),
            sheet = "CHD", skip = 25, col_names = TRUE, n_max = 9) %>%
    slice(-c(1:4)) %>%
  rename_with( ~ c("socio", "MaleNo", "FemaleNo", "PersonNo", "blank1",
                     "MaleCrudeRate", "MaleCrudeCI", "FemaleCrudeRate", "FemaleCrudeCI",
                     "PersonCrudeRate", "PersonCrudeCI", "blank2",
                     "Male", "MaleCI", "Female", "FemaleCI", "Person", "PersonCI")) %>%
    dplyr::select(socio, Male, Female) %>%
  pivot_longer(cols = c("Male", "Female"), names_to = "sex") %>%
  rename(rate = value) %>%
  mutate(socio = case_when(socio=="Group 1 (lowest)" ~ "1", # 1: lowest, to 5: highest
                           socio=="Group 2" ~ "2",
                           socio=="Group 3" ~ "3",
                           socio=="Group 4" ~ "4",
                           socio=="Group 5 (highest)" ~ "5",
                           .default = socio),
         socio = as.numeric(socio)) %>%
  arrange(socio) %>%
  group_by(sex) %>%
  mutate(rr = rate / first(rate)) |>
  ungroup() %>%
  select(socio, sex, rate, rr) %>%
  mutate(cause = "Coronary heart disease")


# Dementia, diabetes and COPD - same as for incidence (dementia and COPD
# mortality data and diabetes prevalence data)
dementia_prev <- dementia_inc %>% mutate(cause = "All cause dementia")
diabetes_prev <- diabetes_inc %>% mutate(cause = "Diabetes type 2")
copd_prev <- copd_inc

# Combine all five diseases
prev_cvd_dem_dia_copd_socio <- bind_rows(chd_prev, dementia_prev, diabetes_prev, 
                                         stroke_prev, copd_prev) %>%
  arrange(cause, sex, socio)

```

#### Combining socioeconomic status with age and sex

We use the method outlined in `Inequalities in health` above to
disaggregate the age and sex data by socioeconomic status.

```{r}
prev_cvd_dem_dia_copd_agesex <- prev_agesex %>%
  filter(cause %in% c("Stroke", "Coronary heart disease", "All cause dementia",
                      "Diabetes type 2", "Chronic obstructive pulmonary disease"))

cvd_dem_dia_copd_prev <- prev_cvd_dem_dia_copd_agesex %>% 
    slice(rep(row_number(), each=5)) %>%
    mutate(socio = rep(1:5, length.out=n())) %>%
    left_join(prev_cvd_dem_dia_copd_socio %>% select(cause, sex, socio, rr_socio = rr), 
              by = c("cause", "sex", "socio")) %>%
    mutate(p_socio = 1/5,    # assumption
           pRR = p_socio * rr_socio,
           socio = ordered(socio))

sum_p <- cvd_dem_dia_copd_prev %>% 
    group_by(cause, age, sex) %>%
    summarise(sum_pRR = sum(pRR), .groups="drop")
    
cvd_dem_dia_copd_prev <- cvd_dem_dia_copd_prev %>%
    left_join(sum_p, by=c("cause", "age", "sex")) %>%
    mutate(rate_soc = rate * rr_socio / sum_pRR, 
           socio = ordered(socio, labels = c("1 (most deprived)",
                                             "2","3","4",
                                             "5 (least deprived)")),
           sex = factor(sex), 
          prob = 1 - exp(-rate_soc))

saveRDS(cvd_dem_dia_copd_prev, file=here("melbourne/health/processed/cvd_dem_dia_copd_prevalence.rds"))
```

We are left with the incidence by age, sex and socioeconomic status in
the variable `rate_soc`. The final dataset is saved in the file
`cvd_dem_dia_copd_prevalence.rds`.

#### Illustration of prevalence estimates

Prevalence by age, sex and socioeconomic quintile for stroke, coronary
heart disease, dementia, type 2 diabetes and COPD.

The published incidence by age and sex (averaged over deprivation
levels) is shown by the dotted black lines (original gbd data
interpolated from 5 year age groups to one year). The estimated
incidence disaggregated by socioeconomic quintile is shown by the
coloured lines, with socioeconomic status indicated by the lightness of
the lines (calculated from gbd data and aihw data).

The relative risk between socioeconomic quintiles is assumed to be the
same between different age/sex groups, but the average of the
deprivation-specific estimates is constrained to be the same as the
published average.

All plots generally show the expected outcome of higher levels of
incidence at higher levels of disadvantage. However, female coronary
heart disease in particular does not strictly follow the order from
highest to lowest, and there is little separation in rates of male
dementia.

```{r}
# plot of data
p <- ggplot(cvd_dem_dia_copd_prev, 
       aes(x=age, y=rate_soc, col=sex, alpha=socio)) + 
    geom_line(lwd=1.5) + 
    geom_line(data=prev_cvd_dem_dia_copd_agesex,
              aes(x=age, y=rate, group=sex), 
              inherit.aes = FALSE,
              lwd=1, lty=2, alpha=0.4, col="black") +
    facet_wrap(~cause, ncol=2, scales="free_y") +
    ylab("Incidence rate (per 100,000)") +
    xlab("Age (years)") +
    coord_cartesian(xlim=c(25, 90)) +
    guides(alpha=guide_legend(title=NULL),
           col=guide_legend(title=NULL)) +
    theme(legend.position = "bottom")

# save plot
# Generate and save all pages
output_dir <- file.path(here("images/Melbourne/prev_cvd_dem_dia_copd/"))
if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
}

ggsave(filename = paste0(output_dir, "/cvd_dem_dia_copd_prevalence.png"), plot = p, 
       width = 12, height = 12, bg = "white")

```

```{r}
cvd_dem_dia_copd_prev <-  cvd_dem_dia_copd_prev %>%
  mutate(measure="prevalence") %>% 
  mutate(socio = as.numeric(case_when(
    socio == "1 (most deprived)" ~ 1,
    socio == "2" ~ 2,
    socio == "3" ~ 3, 
    socio == "3" ~ 4,
    socio == "5 (least deprived)"  ~ 5,
    TRUE ~ NA_real_ ))) %>% # Assign NA for non-classified 
  mutate(sex=as.character(sex)) %>% 
  filter(!is.na(socio)) %>% # Now filtering for non-classified values
  select(socio, cause, measure, age, sex, prob, rate = rate_soc) %>%
  mutate(socio=as.numeric(socio))


```

# Depression incidence and prevalence

For depression, we only have GBD data by age and sex.

```{r}

# Incidence
# Extract the 2018 incidence values from the interpolated GDB data prepared above
depression_incidence <- gbdpyr_interp %>%
  filter(measure == "Incidence" & cause == "Depressive disorders" & year == 2018) %>%
  rename(rate = val_interpolated) %>%
  mutate(prob = 1 - exp(-rate))
  
# Prevalence
# Extract the 2018 prevalence values from the interpolated GDB data prepared above
depression_prevalence <- gbdpyr_interp %>%
  filter(measure == "Prevalence" & cause == "Depressive disorders" & year == 2018) %>%
  rename(rate = val_interpolated) %>%
  mutate(prob = 1 - exp(-rate))

```

# Mortality data

This section shows how mortality data for the JIBE Melbourne
microsimulation is obtained and processed, giving the R code to
reproduce the analysis.

The aim is to produce data describing the annual risk of death for a
synthetic individual in the microsimulation model.

This is defined here as a a function of the individual's age and sex,
area of residence and level of education.

It is calculated based on a combination of routinely-collected data
sources, under the assumption that age and sex, small area of residence
and level of education are independent risk factors for mortality.

## Data sources

### 2016 Australian geography definitions

Statistical Areas level 2 (SA2), as defined for the 2016 census, are
used as the definition of area of residence here. This data file defines
the SA2 areas and their mapping to larger areas.

[Source](https://www.abs.gov.au/ausstats/abs@.nsf/mf/1270.0.55.001)

```{r}
sa2 <- read_csv(here("melbourne/health/original/ABS/SA2_2016_AUST.csv"), col_types = "cccccccccccd")
```

### Mortality by year of age and sex, for Victoria state (not by smaller areas)

[Source](https://www.abs.gov.au/methodologies/life-tables-methodology/2016-2018)

The mortality rate here, `rate`, is defined as "the proportion of
persons dying between exact age x and exact age x+1". For presentation,
this is converted to a rate per 1000 people.

```{r}
dats <- read.csv(here("melbourne/health/original/ABS/3302055001do001_20162018_Table_1.2.csv"),skip=6,
         na=c("","np"), nrows=101)[,1:9]
mf <- rep(c("male","female"),each=4)
names1 <- rep(c("denom","rate","personyears","le"), 2)
names(dats) <- c("age",paste(mf, names1, sep="_"))

victoria_lifetable <- dats |>
  pivot_longer(-age, 
               names_to = c("sex","measure"),
               names_sep = "_") |>
  pivot_wider(names_from="measure", values_from=value) |>
  mutate(rate1000 = rate*1000,
         sex = factor(sex,
                      labels=stringr::str_to_title(sort(unique(.data$sex)))),
         sex = relevel(sex, "Male"))  

# save the lifetable as the mortality rates for the base year (2018)
mort_base <- victoria_lifetable %>%
  dplyr::select(age, sex, rate)
saveRDS(mort_base, here("melbourne/health/processed/mort_base.rds"))
```

### Mortality by SA2 small areas in Victoria (not by age and sex)

[Source](https://adp-access.aurin.org.au/dataset/au-govt-abs-abs-deaths-sa2-2012-2020-sa2-2016)

This is provided as a JSON file, rather than a tabular format, so the R
processing is more complex here.

The *standardised death rate* is published here. This is the expected
number of deaths in the area if the age/sex balance of the area were
same as a standard population. This can be compared between areas to
describe the excess risk in each area not explainable by differences in
age/sex balance.

An area-specific relative rate, relative to the average in the state, is
computed by dividing the (published) standardised rate for that area by
the average standardised rate. The average standardised rate is computed
as a weighted average, weighted by the population in each area

```{r}
#| cache: true
deaths_sa2 <- rjson::fromJSON(file=here("melbourne/health/original/aurin/au-govt-abs-abs-deaths-sa2-2012-2020-sa2-2016.json")) |>
  pluck("features") |>
  tibble() |>
  set_names("area") |>
  unnest_wider(area) |>
  select(properties) |>
  unnest_wider(properties) |>
  select(sa2_code,
         sa2_name,
         pop="_2016_estimated_resident_population_persons",
         deaths="_2016_deaths_no",
         stdrate="_2016_standardised_death_rate_rate") |>
  mutate(stdrate = as.numeric(ifelse(stdrate=="np", NA, stdrate)))
```

For some SA2 areas, standardised death rates are not published. As
explained in the source: "crude rates and Age-standardised Death Rates
(SDRs) based on small numbers are volatile and unreliable. SDRs based on
less than 20 deaths and crude rates based on a very low death count have
not been published and appear as 'np'.".

In these cases, the standardised death rate for the equivalent SA3 area
is used here, from the following
[source](https://data.aurin.org.au/dataset/au-govt-abs-abs-deaths-sa3-2012-2020-sa3-2016)
in the same format as the SA2 data.

```{r}
#| cache: true
deaths_sa3 <- rjson::fromJSON(file=here("melbourne/health/original/aurin/au-govt-abs-abs-deaths-sa3-2012-2020-sa3-2016.json")) |>
  pluck("features") |>
  tibble() |>
  set_names("area") |>
  unnest_wider(area) |>
  select(properties) |>
  unnest_wider(properties) |>
  select(sa3_code,
         sa3_name,
         pop="_2016_estimated_resident_population_persons",
         deaths="_2016_deaths_no",
         stdrate="_2016_standardised_death_rate_rate") |>
  mutate(stdrate = as.numeric(ifelse(stdrate=="np", NA, stdrate)))
```

Finally, a relative mortality rate `RR` is produced for each area,
defined as the rate relative to the average mortality in the state
`stdrate_ave`. This average mortality is defined as a weighted average
of the area-specific rates, weighted by the population of each area.

```{r}
victoria_sa2_deaths <- deaths_sa2 |>
  left_join(sa2, join_by(sa2_code == SA2_MAINCODE_2016)) |>
  filter(STATE_NAME_2016=="Victoria") |>
  select(sa2_code, sa2_name, sa3_code = "SA3_CODE_2016", pop, deaths, stdrate) |>
  mutate(stdrate_ave = with(.data, sum(stdrate*pop,na.rm = TRUE)/sum(pop))) |>
  # Use SA3 rate if SA2 std rate is missing "np" due to small counts 
  left_join(deaths_sa3 |> select(sa3_code, stdrate_sa3 = stdrate), by="sa3_code") |>
  mutate(stdrate = ifelse(is.na(stdrate), stdrate_sa3, stdrate)) |>
  mutate(RR = stdrate / stdrate_ave)
           
melbourne_sa2_deaths <- victoria_sa2_deaths |> 
  filter(sa2_code %in% sa2$SA2_MAINCODE_2016[sa2$GCCSA_NAME_2016=="Greater Melbourne"])
```

### Effects of education on mortality, by age

From [Welsh et al. 2021](https://doi.org/10.1093/ije/dyab080), Table 1.
Age adjusted mortality rates per 100,000 people for high, medium and low
education. Age groups 25-44, 45-64 and 65-84. For the whole of
Australia, using data from the 2016 census linked to death registrations
in 2016 and 2017.

```{r}
rate25 <- c(high=38.8, med=105, low=236) 
rate45 <- c(219, 399, 724)
rate65 <- c(1551, 2201, 3202) 
educ_mort <- as.data.frame(rbind(rate25, rate45, rate65)) |>
  mutate(rrmedium = med/high,
         rrlow = low/high, 
         rrhigh = 1,
         agegroup = c("[25,45)", "[45,65)", "[65,85)")) |>
  pivot_longer(cols=c("rrhigh","rrmedium","rrlow"),
               names_to = "educ",
               names_prefix = "rr",
               values_to = "rr_educ") |>
  select(agegroup, educ, rr_educ) 
```

### Education by area

Proportion in each area who have completed the equivalent of
secondary-school ("medium" education), and proportion with a bachelor's
degree ("high" education), by area. From the 2016 census,
[source](https://data.aurin.org.au/dataset/au-govt-abs-abs-data-by-region-education-and-employment-asgs-sa2-2011-2019-sa2-2016).

This data will be required to appropriately produce mortality rates
disagreggated by both area and education (see below).

```{r}
educarea <- read.csv(here("melbourne/health/original/aurin/education_sa2_aurin.csv")) |>
  filter(yr==2016) |>
  select(sa2_maincode_2016, 
         sa2_name_2016, 
         perc_school = hghst_yr_schl_cmpltd_prsns_agd_15_yrs_cnss_12_eqvlnt_pc,
         perc_degree = prsns_nn_schl_qlfctns_agd_15_yrs_cnss_bchlr_dgre_pc) |>
  mutate(high = perc_degree/100, 
         medium = (perc_school - perc_degree)/100,
         low = 1 - perc_school / 100) |>
  select(sa2_code = sa2_maincode_2016, high, medium, low) |>
  mutate(sa2_code =  as.character(sa2_code)) |>
  left_join(sa2, join_by(sa2_code == SA2_MAINCODE_2016)) |>
  filter(sa2_code %in% sa2$SA2_MAINCODE_2016[sa2$GCCSA_NAME_2016=="Greater Melbourne"]) |>
  select(sa2_code, high, medium, low)
missing_areas <- unique(c(setdiff(melbourne_sa2_deaths$sa2_code, 
                                  educarea$sa2_code), 
                          educarea$sa2_code[is.na(educarea$high)]))

missing_areanames <- sa2$SA2_NAME_2016[sa2$SA2_MAINCODE_2016 %in% missing_areas]
```

`r length(missing_areas)` areas do not have the relevant education data
reported in this dataset (SA2 names `r missing_areanames`). Derive the
proportion in all of Melbourne with high/medium/low education, to impute
for these areas.

```{r}
educ_ave <- educarea |>
  left_join(victoria_sa2_deaths |> select(sa2_code, pop), by="sa2_code") |>
  mutate(high = sum(pop*high, na.rm = TRUE)/sum(pop,na.rm=TRUE),
         medium = sum(pop*medium, na.rm = TRUE)/sum(pop,na.rm=TRUE),
         low = 1 - high - medium) |>
  select(high, medium, low) |>
  head(1)
educarea <- educarea |> 
  filter(!is.na(high), !is.na(medium)) |>
  rbind(data.frame(sa2_code = missing_areas) |>
          cross_join(educ_ave))
```

## Combining data sources

The goal is to estimate the probabilities of death within a year, in
Melbourne, by year of age, sex, area of residence (SA2) and education
level. These rates apply to the baseline scenario for the
microsimulation model. Assume that alternative scenarios (in which
disease/death risks are modified) may be handled by multiplying these
baseline risks by relative risks of exposure changes.

Firstly, we illustrate two of our sources of data together: (a)
age/sex-specific mortality for Victoria, and (b) variation between SA2
areas in mortality (averaged over age/sex within each area)

```{r}
ggplot(victoria_lifetable, aes(x=age, y=rate1000, col=sex)) + 
  geom_hline(data=victoria_sa2_deaths, aes(yintercept = stdrate), 
             col="blue", alpha=0.3, lwd=1.05) +
  geom_line(lwd=1.5) +
  labs(col="") +
  scale_y_continuous(trans="log", 
                     breaks=c(0.0002, 0.0005, 0.001, 0.005, 
                              0.01, 0.05, 0.1, 0.2)*1000) + 
  scale_x_continuous(breaks=seq(0,100,10)) +
  theme_bw() + 
  theme(legend.position = c(0.5, 0.1), 
        legend.justification = "bottom",
        legend.background = element_blank()) +
  annotate(geom="text", x=0, y=20, 
           label="Standardised average rates by small area", 
           col="blue", alpha=0.6, hjust=0) + 
  xlab("Age") + ylab("Mortality rate (per 1000 person-years)") +
  annotate(geom="text", x=10, y=500, 
           label="Average over areas in state, by age and sex", 
           col="blue", alpha=0.6, hjust=0)
#saveRDS(victoria_lifetable, "data-r/victoria_lifetable.rds")
```

These are combined as follows to estimate mortality rates by both area
and age/sex.

### Independence model for variations between areas and between age/sex

We assume that the excess mortality risk associated with living in a
particular area does not depend on age and sex. We then estimate the
area-specific mortality rate for people of a particular age/sex by
multiplying the state-wide rate by the area-specific, relative
standardised rate.

```{r vic_mort_dep,fig.width=7,fig.height=4}
deaths_age_sa2 <- victoria_lifetable |>
  select(age, sex, rate1000) |>
  cross_join(melbourne_sa2_deaths |> 
               select(sa2_code, sa2_name, RR)) |>
  mutate(rate1000 = rate1000*RR,
         area_sex = paste(sa2_code,sex))
```

These are illustrated:

```{r}
deaths_age_sa2 |>
  filter(sa2_code %in% sample(unique(.data$sa2_code), 100)) |>
  droplevels() |>
ggplot(aes(x=age, y=rate1000, col=sex, group=sa2_code)) + 
  geom_line(lwd=1, alpha=0.2) +
  labs(col="") +
  facet_grid(cols=vars(sex)) +
  scale_y_continuous(trans="log", 
                     breaks=c(0.0002, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1, 0.2)*1000) + 
  scale_x_continuous(breaks=seq(0,100,10)) +
  theme_bw() +
  theme(legend.position = "none") +
  xlab("Age") + ylab("Mortality rate (per 1000 person-years)")
```

Note that knowing the age balance of each area would not help further to
explain these between-area variations, since the age balance is already
accounted for in the standardised rates.

### Including other predictors of mortality

We use the method outlined in `Inequalities in health` above to
disaggregate the age and sex data by socioeconomic status.

We have previously estimated mortality by age, sex and area. We use this
method to further disaggregate mortality rates by level of education,
given data on agegroup-specific education effects on mortality and rates
of education by area. This assumes that the education effects are
independent of year of age (within broad age groups), sex and area.

### Disaggregating age/sex/area mortality by education

The effects of education on mortality are published for three age groups
(25-44, 45-64 and 65-84). Outside these age groups, mortality effects
are assumed to be independent of education level.

```{r}
mort_disagg <- deaths_age_sa2 |> 
  left_join(educarea, by="sa2_code") |>
  pivot_longer(cols = c("high","medium","low"), 
               names_to = "educ", values_to = "p_educ") |>
  mutate(agegroup = cut(age, c(0, 25, 45, 65, 85, Inf),
                        right=FALSE, include.lowest = TRUE)) |>
  left_join(educ_mort, by=c("agegroup","educ")) |>
  mutate(pRR = rr_educ * p_educ) 

sum_p <- mort_disagg |> group_by(age, sa2_code) |> 
  summarise(sum_pRR = sum(pRR), .groups="drop")

mort_disagg <- mort_disagg |> 
  left_join(sum_p, by=c("age","sa2_code")) |>
  rename(rate_ave_educ = rate1000) |>
  mutate(disag_educ = ifelse(between(age, 25, 84) & 
                               (!(sa2_code %in% missing_areas)), 
                             rr_educ / sum_pRR, 1),
         rate = rate_ave_educ * disag_educ) |>
  # these 'rates' are derived from qx ("the proportion of persons dying between 
  # exact age x and exact age x+1"), so treat as a probability and calculate rate
  mutate(prob = rate / 1000,  # note 'rate' was per 1000 people
         rate = -log(1 - prob) * 1000) %>%
  filter(sa2_code %in% sa2$SA2_MAINCODE_2016[sa2$GCCSA_NAME_2016=="Greater Melbourne"])

# save the combined disaggregation factors for SA2 and education (should be 4635 rows:
# 309 SA2s * 3 education levels * 5 age groups)
mort_disagg_factors <- mort_disagg %>%
  mutate(disagg_factor = RR * disag_educ) %>%
  dplyr::select(sa2_code, sa2_name, educ, agegroup, disagg_factor) %>%
  distinct()
saveRDS(mort_disagg_factors, here("melbourne/health/processed/mort_disagg_factors.rds"))

mort_disagg <- mort_disagg %>%
  select(age, sex, sa2_code, sa2_name, educ, rate, prob)
saveRDS(mort_disagg, file=here("melbourne/health/processed/mort_disagg.rds"))

```

The final dataset produced contains the following columns

`age` Year of age

`sex` Sex

`sa2_code` SA2 area code (2016 definitions)

`sa2_name` SA2 area name

`educ` Level of education (low: no secondary school qualification,
medium: secondary school but no bachelor's degree, high: bachelor's
degree)

`rate` Mortality rate per 1000 person-years

`prob` Annual mortality risk

and `r nrow(mort_disagg)` rows, one for each of 2 sexes $\times$ 101
years of age $\times$ 3 levels of education $\times$ 309 SA2 areas in
Melbourne.

```{r,echo=FALSE}
stopifnot(nrow(mort_disagg)==187254)
```

First five rows:

```{r}
head(mort_disagg, 5)
```

## Summaries of annual mortality probabilities

For each age group, sex and education level, this table shows the median
(min-max) annual mortality risk over areas and single years of age.

```{r}
#| rows.print: 30
agecut <- c(0, 18, 45, 65, 80, Inf)
mort_disagg |> 
  mutate(agegroup = cut(age, agecut, right=FALSE, include.lowest = TRUE)) |>
  group_by("Age group"=agegroup, "Sex"=sex, "Education"=educ) |>
  summarise(Median = median(prob), Min = min(prob), Max = max(prob), .groups="drop") |>
  gt() |>
  fmt_number(n_sigfig=2) |>
  cols_align_decimal() |>
  cols_merge_range(Min, Max) |>
  cols_label(Min = "Range")
```

```{r}
mort_disagg <- mort_disagg %>%
                mutate(cause = "all cause", 
                       measure = "deaths", 
                       sa2_code=as.numeric(sa2_code))
          
```

# Combine incidence, prevalence and mortality

Combine all data sources for incidence, prevalence and mortality in one
file, then save required output files.

```{r}

# SA2 codes
SA2_Melb <- read.csv(here("melbourne/health/original/ABS/SA2_2016_AUST.csv")) %>%
  dplyr::select(SA2_MAINCODE_2016, SA2_5DIGITCODE_2016, GCCSA_NAME_2016) %>%
  filter(GCCSA_NAME_2016 == "Greater Melbourne")

# assemble all required files
data_melbourne <- mort_disagg %>% 
  bind_rows(cancer_incidence_area, cancer_prevalence_area, 
            cvd_dem_dia_copd_inc, cvd_dem_dia_copd_prev, 
            depression_incidence, depression_prevalence) %>%
  mutate(measure=tolower(measure)) %>%
  
  # standardise disease names
  mutate(cause = tolower(cause)) %>%
  mutate(cause = case_when(
    cause == "alzheimer's disease and other dementias" ~ "all_cause_dementia",
    cause == "all cause"                               ~ "all_cause_mortality",
    cause == "chronic obstructive pulmonary disease"   ~ "copd",
    cause == "ischemic heart disease"                  ~ "coronary_heart_disease",
    cause == "depressive disorders"                    ~ "depression",
    cause == "diabetes mellitus type 2"                ~ "diabetes",
    cause == "diabetes type 2"                         ~ "diabetes",
    .default = cause
  )) %>%
  mutate(cause = gsub(" ", "_", cause)) %>%
  
  # complete age from ageyr where necessary
  mutate(age = ifelse(is.na(age) & !is.na(ageyr), ageyr, age)) %>%
  
  # filter to Greater Melbourne, where SA2 is available
  filter(sa2_code %in% SA2_Melb$SA2_MAINCODE_2016 | 
           sa2_code %in% SA2_Melb$SA2_5DIGITCODE_2016 | 
           is.na(sa2_code)) %>%

  select(age, sex, sa2_code, sa2_name, educ, rate, prob, cause, measure, socio)

write_csv(data_melbourne, file=here("melbourne/health/processed/data_melbourne.csv"))


# combined output file for mortality and incidence
mort_inc_melbourne <- data_melbourne %>%
  filter(measure %in% c("deaths", "incidence")) %>%
  filter(!is.na(rate)) %>%  # several non-modelled cancers do not have rates for incidence
  mutate(location_code = case_when(
    !is.na(sa2_code) & !is.na(educ) & !is.na(socio) ~ 
      paste(as.character(sa2_code), educ, sep = "_"),  # don't need socio if have SA2
    !is.na(sa2_code) & !is.na(educ)  ~ paste(as.character(sa2_code), educ, sep = "_"),
    !is.na(sa2_code) & !is.na(socio) ~ as.character(sa2_code),  # don't need socio if have SA2
    !is.na(educ) & !is.na(socio)     ~ paste(educ, socio, sep = "_"),
    !is.na(sa2_code)                 ~ as.character(sa2_code),
    !is.na(socio)                    ~ as.character(socio),
    !is.na(educ)                     ~ educ,
    TRUE                             ~ NA
  ),
  location_type = case_when(
    !is.na(sa2_code) & !is.na(educ) & !is.na(socio) ~ "SA2_educ",  # don't need socio if have SA2
    !is.na(sa2_code) & !is.na(educ)  ~ "SA2_educ",
    !is.na(sa2_code) & !is.na(socio) ~ "SA2",  # don't need socio if have SA2
    !is.na(educ) & !is.na(socio)     ~ "educ_socio",
    !is.na(sa2_code)                 ~ "SA2",
    !is.na(socio)                    ~ "socio",
    !is.na(educ)                     ~ "educ",
    TRUE                             ~ NA
  )) %>%
  mutate(sex = tolower(sex)) %>%
  dplyr::select(age, sex, location_code, cause, rate, measure, location_type)

write_csv(mort_inc_melbourne, 
          file = here("melbourne/health/processed/health_transitions_melbourne_raw.csv"))

# output file for prevalence
prev_melbourne <- data_melbourne %>%
  filter(measure == "prevalence") %>% 
  left_join(SA2_Melb, by = c("sa2_code"= "SA2_5DIGITCODE_2016")) %>%
  dplyr::select(-sa2_code) %>%
  rename(sa2_code = SA2_MAINCODE_2016) %>%
  mutate(location_code = case_when(
    !is.na(sa2_code) & !is.na(educ) & !is.na(socio) ~ 
      paste(as.character(sa2_code), educ, sep = "_"),  # don't need socio if have SA2
    !is.na(sa2_code) & !is.na(educ)  ~ paste(as.character(sa2_code), educ, sep = "_"),
    !is.na(sa2_code) & !is.na(socio) ~ as.character(sa2_code),  # don't need socio if have SA2
    !is.na(educ) & !is.na(socio)     ~ paste(educ, socio, sep = "_"),
    !is.na(sa2_code)                 ~ as.character(sa2_code),
    !is.na(socio)                    ~ as.character(socio),
    !is.na(educ)                     ~ educ,
    TRUE                             ~ NA
  ),
  location_type = case_when(
    !is.na(sa2_code) & !is.na(educ) & !is.na(socio) ~ "SA2_educ",  # don't need socio if have SA2
    !is.na(sa2_code) & !is.na(educ)  ~ "SA2_educ",
    !is.na(sa2_code) & !is.na(socio) ~ "SA2",  # don't need socio if have SA2
    !is.na(educ) & !is.na(socio)     ~ "educ_socio",
    !is.na(sa2_code)                 ~ "SA2",
    !is.na(socio)                    ~ "socio",
    !is.na(educ)                     ~ "educ",
    TRUE                             ~ NA
  )) %>%
  mutate(sex = case_when(
    sex == "Male" ~ 1,
    sex == "Female" ~ 2
  )) %>%
  dplyr::select(age, sex, location_code, cause, rate, measure, location_type)

write_csv(prev_melbourne, 
          file = here("melbourne/health/processed/health_transitions_melbourne_prevalence.csv"))

```

# Combine incidence and mortality as required for SILO/MITO

SILO/MITO code requires all-cause mortality and disease incidence, disaggregated by age, sex and SA2 (and no other disaggregation), probability (and not rate), for age 0 to 100.

Combine to meet these requirements, and save

```{r}

# mortality - use 'deaths_age_sa2', which is deaths before disaggregation
SM_mort <- deaths_age_sa2 %>%
  
  # the 'rates' are derived from qx ("the proportion of persons dying between 
  # exact age x and exact age x+1"), so treat as a probability (same as above)
  mutate(prob = rate1000 / 1000, # note 'rate' was per 1000 people
         sex = case_when(
           sex == "Male" ~ 1,
           sex == "Female" ~ 2
         ),
         cause = "all_cause_mortality",
         sa2_code = as.numeric(sa2_code)) %>%
  dplyr::select(SA2_MAIN16 = sa2_code, age, sex, cause, prob)

# incidence - use data_melbourne
SM_inc_base <- data_melbourne %>%
  filter(measure == "incidence") %>%
  filter(!is.na(rate)) %>%  # some non-modelled cancers lack incidence rates or probabilities
  mutate(sex = case_when(
           sex == "Male" ~ 1,
           sex == "Female" ~ 2
         )) %>%
  dplyr::select(SA2_MAIN16 = sa2_code, age, sex, cause, prob, socio)
  
# some incidence only goes to 95 or 99; where that happens, replicate to 100
SM_inc_oldage <- SM_inc_base %>%
  
  # select oldest age, and keep if < 100
  group_by(cause) %>%
  filter(age == max(age)) %>%
  ungroup() %>%
  filter(age < 100) %>%
  
  # replicate by number of years remaining to 100
  rowwise() %>%
  mutate(age = list((age + 1):100)) %>%
  unnest(age) %>%
  ungroup()

SM_inc_age <- bind_rows(SM_inc_base, SM_inc_oldage)

# SA2 codes and socio-economic quintiles (note - 4SA2s are industrial areas
# with no population - West Melbourne, Port Melbourne Industrial, 
# Moorabbin Airport, Essendon Airport) - these will be given undisaggregated ### median?### values
SA2_SES <- data_melbourne %>%
  dplyr::select(sa2_name, sa2_code, socio) %>%
  filter(sa2_code %in% SA2_Melb$SA2_MAINCODE_2016) %>%
  distinct() %>%
  # convert NAs to 0, but only keep where there is no actual socio
  mutate(socio = ifelse(is.na(socio), 0, socio)) %>%
  group_by(sa2_code) %>%
  filter(socio == max(socio)) %>%  # omits all NAs, unless NA (now 0) is the only socio for that SA2
  ungroup()

missing_SES <- SA2_SES %>%
  filter(socio == 0) %>%
  .$sa2_code

# cancers - use mediabn values for the 4 SA2s with no disaggregated values
# collect cancer values (only cancers have SA2s)
SM_inc_cancer_SA2 <- SM_inc_age %>%
  filter(!is.na(SA2_MAIN16))

# median values for SA2s missing SES
SM_inc_cancer_median <- SM_inc_cancer_SA2 %>%
  group_by(age, sex, cause) %>%
  summarise(prob = median(prob)) %>%
  ungroup() %>%
  
  # replicate median values for the missing SA2s
  rowwise() %>%
  mutate(SA2_MAIN16 = list(missing_SES)) %>%
  unnest(SA2_MAIN16) %>%
  ungroup()

SM_inc_cancer <- bind_rows(SM_inc_cancer_SA2, SM_inc_cancer_median)

# others (except depression) - attribute socio values to all SA2s of that
# socio level; and use the middle socio level (level 3) for the 4 SA2s with no 
# socio (which were previously coded as socio = 0)
SM_inc_non_cancer <- SM_inc_age %>%
  filter(is.na(SA2_MAIN16) & !is.na(socio)) %>%
  full_join(SA2_SES %>% mutate(socio = ifelse(socio == 0, 3, socio)),
            by = "socio", relationship = "many-to-many") %>%
  mutate(SA2_MAIN16 = sa2_code)

# depression - no disaggregation available, so same value for all SA2s
SM_inc_depression <- SM_inc_age %>%
  filter(is.na(SA2_MAIN16) & is.na(socio)) %>%
  
  # stretch out for all SA2s
  rowwise() %>%
  mutate(SA2_MAIN16 = list(SA2_SES$sa2_code)) %>%
  unnest(SA2_MAIN16) %>%
  ungroup()


# combine and adjust causes to match SILO/MITO expected names (see
# silo/extensions/health/src/main/java/de/tum/bgu/msm/health/disease/Diseases.java)
SM <-  bind_rows(SM_mort, SM_inc_cancer, SM_inc_non_cancer, SM_inc_depression) %>%
  dplyr::select(SA2_MAIN16, age, sex, cause, prob) %>%
  mutate(cause = case_when(
    cause == "all_cancers"          ~ "all_cause_cancer",
    cause == "head_and_neck_cancer" ~ "head_neck_cancer",
    TRUE                           ~ cause
  ))

# write output
write_csv(SM, 
          file = here("melbourne/health/processed/health_transitions_melbourne.csv"))


```

# Trends

## Mortality trends

```{r}
library(readxl)

# Read the Excel sheet and skip the first 6 rows
mort_trends <- read_excel(here("melbourne/health/original/ABS/32220ds02_2022-2071_projection_assumptions_detailed.xlsx"), 
                          sheet = "Table 5", skip = 6)

# Select specific columns (1, 2, 4, and 13)
mort_trends <- mort_trends %>%
  select(1, 2, 4, 14) %>%
  rename(male=`Victoria...4`, 
         female = Victoria...14) 

mort_trends_ord <- mort_trends %>%
                   arrange(Age) %>% 
                    pivot_longer(cols = c("male", "female"), 
                                 names_to = "sex") %>%
                    rename(rate = value) %>%
                    mutate(sex=as.factor(sex)) %>%
                    arrange(sex) %>%
                    mutate(diff=rate - lag(rate)) 

mort_trends_ord[5101, "diff"] <- 0 # modify male diff for 0 age 2022 as it compare with females. 

mort_trends_ord[1, "diff"] <- 0 # modify female diff for 0 age 2022 as it is NA. 
                    
# For comparison, trends as predicted in 2017-66 data from ABS
mort_trends_former_ord <- 
  read_excel(here("melbourne/health/original/ABS/projections 2017-2066.xls"),
             sheet = "Table 5", skip = 6) %>%
  select(1, 2, 4, 14) %>%
  rename(male=`Victoria...4`, 
         female = Victoria...14) %>%
  arrange(Age) %>% 
  pivot_longer(cols = c("male", "female"), 
               names_to = "sex") %>%
  rename(rate = value) %>%
  mutate(sex = as.factor(sex)) %>%
  arrange(sex) %>%
  mutate(diff = rate - lag(rate)) %>%
  mutate(diff = ifelse(Year == 2017 & Age == 0, 0, diff))

# Combine current and former into a long dataset of rates,
# with the rates described as 'pred' (for 'prediction')
mort_trends_combined <- mort_trends_ord %>%
  full_join(mort_trends_former_ord,
             by = c("Year", "Age", "sex"),
             suffix = c("_2022_71", "_2017_66")) %>%
  dplyr::select(Year, Age, sex, rate_2022_71, rate_2017_66) %>%
  pivot_longer(cols = c("rate_2022_71", "rate_2017_66"),
               names_to = "type", values_to = "rate") %>%
  filter(!is.na(rate)) %>%
  mutate(type = case_when(
    type == "rate_2022_71" ~ "pred_2022-71",
    type == "rate_2017_66" ~ "pred_2017-66"
  )) %>%
  mutate(group = paste0(sex, "_", type))


```

Do some graphs to check trends on data

```{r}
library(ggplot2)
library(ggforce)


# Create a directory to save the plots
output_dir <-  file.path(here("images/mortality_trends/"))
if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}

library(ggplot2)



# Define the number of facets per page
facets_per_page <- 20  # Adjust this number as needed

# Split ages into chunks based on the desired number of facets per page
ages <- unique(mort_trends_ord$Age)
chunks <- split(ages, ceiling(seq_along(ages) / facets_per_page))

# Function to save plots
save_plot <- function(plot, page_number) {
  file_name <- file.path(output_dir, paste0("plot_page_", page_number, ".png"))
  ggsave(file_name, plot = plot, width = 12, height = 10, bg = "white")  # Adjust dimensions as needed
}

# Generate and save plots
for (i in seq_along(chunks)) {
  # Subset data for current chunk
  age_subset <- mort_trends_ord[mort_trends_ord$Age %in% chunks[[i]], ]
  
  # Calculate y-axis limits
  y_min <- min(age_subset$rate, na.rm = TRUE)
  y_max <- max(age_subset$rate, na.rm = TRUE)
  y_padding <- 0.1 * (y_max - y_min)  # Add 10% padding to the range
  y_limits <- c(y_min - y_padding, y_max + y_padding)
  
  # Create the plot with adjusted y-axis and white background
  p <- ggplot(age_subset, aes(x = Year, y = rate, color = sex, group = sex)) +
    geom_line() +
    labs(title = paste("Line Chart by Sex Group - Page", i),
         x = "Year", y = "Rate") +
    facet_wrap(~ Age, ncol = 5) +  # Adjust number of columns to fit your layout
    scale_y_continuous(limits = y_limits) +  # Set y-axis limits
    theme_minimal() +
    theme(panel.background = element_rect(fill = "white"),
          plot.background = element_rect(fill = "white"))  # Ensure plot background is white
  
  # Save the plot to a file
  save_plot(p, i)
}

## Plots to compare former (2017-66) with current (2022-71) projections,
## and also rates from 'victoria_lifetable' 
# Function to save plots
save_plot <- function(plot, page_number) {
  file_name <- file.path(output_dir, paste0("plot_page_compare", page_number, ".png"))
  ggsave(file_name, plot = plot, width = 12, height = 10, bg = "white")  # Adjust dimensions as needed
}

# Generate and save plots
for (i in seq_along(chunks)) {
  # Subset data for current chunk
  age_subset <- mort_trends_combined[mort_trends_combined$Age %in% chunks[[i]], ]
  
  # Calculate y-axis limits
  y_min <- min(age_subset$rate, na.rm = TRUE)
  y_max <- max(age_subset$rate, na.rm = TRUE)
  y_padding <- 0.1 * (y_max - y_min)  # Add 10% padding to the range
  y_limits <- c(y_min - y_padding, y_max + y_padding)
  
  # Create the plot with adjusted y-axis and white background
  p <- ggplot(age_subset, aes(x = Year, y = rate, color = group, group = group)) +
    geom_line() +
    geom_hline(data = victoria_lifetable %>%
                 dplyr::select(Age = age, sex, rate) %>%
                 mutate(sex = case_when(
                   sex == "Female" ~ "female_actual_2016-18",
                   sex == "Male"   ~ "male_actual_2016-18"
                 )) %>%
                 filter(Age %in% age_subset$Age), 
               aes(yintercept = rate, color = sex), 
               linetype = "dashed") +

    labs(title = paste("Line Chart by Sex Group - Page", i),
         x = "Year", y = "Rate") +
    facet_wrap(~ Age, ncol = 5) +  # Adjust number of columns to fit your layout
    scale_y_continuous(limits = y_limits) +  # Set y-axis limits
    theme_minimal() +
    theme(panel.background = element_rect(fill = "white"),
          plot.background = element_rect(fill = "white"))  # Ensure plot background is white
  
  # Save the plot to a file
  save_plot(p, i)
}

cat("Plots have been saved in the 'images/mortality_trends' directory.\n")


```

```{r}
# combined table of mortality rates for 2018 (base) and 2019-22 plus
# projections from 2023-2071

# base year (2018)
mort_base <- readRDS(here("melbourne/health/processed/mort_base.rds")) %>%
  rename(rate_2018 = rate)

# life tables 2019-22
mort_year <- function(mort_year_location, year) {
  output <- read_xlsx(here(mort_year_location), sheet = "Table_1.2", skip = 6,
                      col_names = TRUE, n_max = 102) %>%
    rename_with(~ c("age", "male_lx", "male_qx", "male_Lx", "male_ex",
                    "female_lx", "female_qx", "female_Lx", "female_ex")) %>%
    dplyr::select(age, Male = male_qx, Female = female_qx) %>%
    pivot_longer(cols = c("Male", "Female"), names_to = "sex",
                 values_to = paste0("rate_", year))
}
mort_2019 <- mort_year("melbourne/health/original/ABS/3302055001DO001_20172019.xlsx", 2019)
mort_2020 <- mort_year("melbourne/health/original/ABS/3302055001DO001_20182020.xlsx", 2020)
mort_2021 <- mort_year("melbourne/health/original/ABS/3302055001DO001_20192021.xlsx", 2021)
mort_2022 <- mort_year("melbourne/health/original/ABS/3302055001DO001_20202022.xlsx", 2022)

# projections in wide format, from 2023
mort_proj <- mort_trends_ord %>%
  dplyr::select(Year, age = Age, sex, rate) %>%
  filter(Year >= 2023) %>%
  mutate(sex = str_to_title(sex)) %>%
  pivot_wider(names_from = Year, names_prefix = "rate_", values_from = rate) 
  
  
mort_years <- mort_base %>%
  left_join(mort_2019, by = c("age", "sex")) %>%
  left_join(mort_2020, by = c("age", "sex")) %>%
  left_join(mort_2021, by = c("age", "sex")) %>%
  left_join(mort_2022, by = c("age", "sex")) %>%
  left_join(mort_proj, by = c("age", "sex"))

# save the output
saveRDS(mort_years, here("melbourne/health/processed/mort_years.rds"))
write.csv(mort_years, here("melbourne/health/processed/mort_years.csv"), row.names = F)

# plot the outputs
mort_years_long <- mort_years %>%
  pivot_longer(cols = starts_with("rate"), names_to = "year", values_to = "rate") %>%
  mutate(year = as.numeric(gsub("rate_", "", year)))

# Create a directory to save the plots
output_dir <-  file.path(here("images/mortality_trends/"))
if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}

# Define the number of facets per page
facets_per_page <- 20  # Adjust this number as needed

# Split ages into chunks based on the desired number of facets per page
ages <- unique(mort_years_long$age)
chunks <- split(ages, ceiling(seq_along(ages) / facets_per_page))

# Function to save plots
save_plot <- function(plot, page_number) {
  file_name <- file.path(output_dir, paste0("plot_years_", page_number, ".png"))
  ggsave(file_name, plot = plot, width = 12, height = 10, bg = "white")  # Adjust dimensions as needed
}

# Generate and save plots
for (i in seq_along(chunks)) {
  # Subset data for current chunk
  age_subset <- mort_years_long[mort_years_long$age %in% chunks[[i]], ]
  
  # Calculate y-axis limits
  y_min <- min(age_subset$rate, na.rm = TRUE)
  y_max <- max(age_subset$rate, na.rm = TRUE)
  y_padding <- 0.1 * (y_max - y_min)  # Add 10% padding to the range
  y_limits <- c(y_min - y_padding, y_max + y_padding)
  
  # Create the plot with adjusted y-axis and white background
  p <- ggplot(age_subset, aes(x = year, y = rate, color = sex, group = sex)) +
    geom_line() +
    labs(title = paste("Line Chart by Sex Group - Page", i),
         x = "Year", y = "Rate") +
    facet_wrap(~ age, ncol = 5) +  # Adjust number of columns to fit your layout
    scale_y_continuous(limits = y_limits) +  # Set y-axis limits
    theme_minimal() +
    theme(panel.background = element_rect(fill = "white"),
          plot.background = element_rect(fill = "white"))  # Ensure plot background is white
  
  # Save the plot to a file
  save_plot(p, i)
}

```

## Prevalence trends

Prevalence rates for 2018 and subsequent years. We have not identified
useful prevalence projections for the relevant diseases.

This consists of prevalence rates from GBD for 2018 to 2021 for all
relevant diseases, plus rates from AIHW for specific years for diabetes,
dementia \[and COPD\]. **SP note: the COPD figures from AIHW are much
lower than from GBD, and this may be because the AIHW figures only cover
ICD J43-J44, whereas the GBD figures cover J41-J44. Possibly the COPD
figures here are not useful and should be discarded.**

```{r}
# GBD prevalence for all relevant diseases, 2018-21
gbd_prev <- prev_agesex_all %>%
  mutate(type = "actual", source = "GBD", cause = tolower(cause)) %>%
  dplyr::select(year, type, source, cause, sex, age, rate)
  

# AIHW dementia prevalence, 2022, ages 60 to 90
dem_prev_base <- read_xlsx(here("melbourne/health/original/AIHW/dementia-prevalence.xlsx"),
                           sheet = "S2.1", skip = 2, col_names = TRUE, n_max = 17) %>%
  rename_with(~ c("sex", "age_range", "no", "no_1000")) %>%
  dplyr::select(sex, age_range, no_1000) %>%
  fill(sex) %>%
  slice(-c(1, 9, 10)) %>%
  mutate(sex = case_when(sex == "Women" ~ "Female", sex == "Men" ~ "Male")) %>%
  # convert rates per 1000 to rate per person
  mutate(rate_1 = no_1000 / 1000) %>%
    # break age ranges into from and to
  mutate(age_range = ifelse(age_range == "90+", "90–94", age_range)) %>%
  separate_wider_delim(age_range, "–", names = c("from_age", "to_age")) %>%
  mutate(across(from_age:to_age, as.numeric),
         agediff = to_age - from_age + 1) %>%
  # group for interpolation
  group_by(sex) %>%
  arrange(sex, from_age)

# interpolate
dem_prev_interp <- group_modify(dem_prev_base, disagg_smooth_spline) %>%
  ungroup()
  
# finalise
dem_prev <- dem_prev_interp %>%
  mutate(year = 2022, type = "actual", source = "AIHW", 
         cause = "all cause dementia") %>%
  dplyr::select(year, type, source, cause, sex, age = ageyr, 
                rate = val_interpolated)


# AIHW diabetes prevalence, 2021, ages 40 to 85
dia_prev_base <- read_xlsx(here("melbourne/health/original/AIHW/diabetes-prevalence.xlsx"),
                        sheet = "Type 2 prevalence", skip = 5, col_names = TRUE,
                        n_max = 11) %>%
  slice(-1) %>%
  rename_with(~ c("age_range", "MaleNo", "FemaleNo", "PersonNo",
                  "Male", "Female", "Person")) %>%
  dplyr::select(age_range, Female, Male) %>%
  pivot_longer(cols = c("Female", "Male"), names_to = "sex", values_to = "rate_pct") %>%
  # convert percentage rates to rate per person
  mutate(rate_1 = rate_pct / 100) %>%
  # break age ranges into from and to
  mutate(age_range = ifelse(age_range == "85+", "85–89", age_range),) %>%
  separate_wider_delim(age_range, "–", names = c("from_age", "to_age")) %>%
  mutate(across(from_age:to_age, as.numeric),
         agediff = to_age - from_age + 1) %>%
  # group for interpolation
  group_by(sex) %>%
  arrange(sex, from_age)

# interpolate
dia_prev_interp <- group_modify(dia_prev_base, disagg_smooth_spline) %>%
  ungroup()

# finalise
dia_prev <- dia_prev_interp %>%
  mutate(year = 2021, type = "actual", source = "AIHW", 
         cause = "diabetes type 2") %>%
  dplyr::select(year, type, source, cause, sex, age = ageyr, 
                rate = val_interpolated)


# AIHW COPD prevalence (multisource), 2018-19, ages 35 to 95
copd_prev_base <- read_xlsx(here("melbourne/health/original/AIHW/copd-prevalence-multisource.xlsx"),
                            sheet = "Data extract", skip = 6, col_names = TRUE, n_max = 144) %>%
  rename_with(~ c("year", "sex", "age_range", "population", "PBS_cases", 
                  "PBS_prevalence", "Multisource_cases", "Multisource_prevalence",
                  "Multisource_prevalence_std")) %>%
  dplyr::select(year, sex, age_range, rate_pct = Multisource_prevalence) %>%
  filter(year >= 2018 & 
           sex %in% c("Women", "Men") & 
           !age_range %in% c("35+", "40+", "45+")) %>%
  mutate(sex = case_when(sex == "Women" ~ "Female", sex == "Men" ~ "Male")) %>%
  # convert percentage rates to rate per person
  mutate(rate_1 = rate_pct / 100) %>%
    # break age ranges into from and to
  mutate(age_range = ifelse(age_range == "95+", "95-99", age_range)) %>%
  separate_wider_delim(age_range, "-", names = c("from_age", "to_age")) %>%
  mutate(across(from_age:to_age, as.numeric),
         agediff = to_age - from_age + 1) %>%
  # group for interpolation
  group_by(year, sex) %>%
  arrange(year, sex, from_age)
  
# interpolate
copd_prev_interp <- group_modify(copd_prev_base, disagg_smooth_spline) %>%
  ungroup()
  
# finalise
copd_prev <- copd_prev_interp %>%
  mutate(type = "actual", source = "AIHW", 
         cause = "chronic obstructive pulmonary disease") %>%
  dplyr::select(year, type, source, cause, sex, age = ageyr, 
                rate = val_interpolated)


# combine and save
prev_trends <- bind_rows(gbd_prev, dem_prev, dia_prev, copd_prev)
saveRDS(prev_trends, file=here("melbourne/health/processed/health_prev_trends.rds"))
write.csv(prev_trends, here("melbourne/health/processed/health_prev_trends.csv"), row.names = F)

```

# Mortality outputs

Combine saved mortality tables: - `mort_years.rds`: mortality rates for
the years 2018 to 2017 by age and sex. - `mort_disagg_factors.rds`:
relative rates to apply to the mortality rates to disaggregate by SA2
and education.

```{r}
# read in the saved tables
mort_years <- readRDS(here("melbourne/health/processed/mort_years.rds"))
mort_disagg_factors <- readRDS(here("melbourne/health/processed/mort_disagg_factors.rds"))

# calculate disaggregated rates, with option to select a single year
mort <- mort_years %>%
  
  # convert to long form
  pivot_longer(cols = starts_with("rate"), names_to = "year", values_to = "rate") %>%
  mutate(year = as.numeric(gsub("rate_", "", year))) %>%
  
  # # filter to specific year if required
  # filter(year == 2018) %>%
  
  # add agegroup column to match the groups in mort_disagg_factors
  mutate(agegroup = cut(age, c(0, 25, 45, 65, 85, Inf),
                        right=FALSE, include.lowest = TRUE)) %>%
  
  # join the disagg_factors (disaggregated for SA2 and education)
  left_join(mort_disagg_factors, by = c("agegroup"),
            relationship = "many-to-many") %>%
  
  # calculate disaggregated rates (per 1000)
  mutate(rate = rate * 1000 * disagg_factor) %>%
  
  # these 'rates' are derived from qx ("the proportion of persons dying between 
  # exact age x and exact age x+1"), so treat as a probability and calculate rate
  mutate(prob = rate / 1000,  # note 'rate' was per 1000 people
         rate = -log(1 - prob) * 1000) %>%
  
  # select required fields
  dplyr::select(age, sex, year, sa2_code, sa2_name, educ, rate, prob)

```
